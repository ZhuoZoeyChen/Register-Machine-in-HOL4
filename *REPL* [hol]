
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Tue Sep 24 11:26:04 2019)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
** Load path (see loadPath variable) now contains 2 entries
** after consulting Holmakefiles

> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> val it = (): unit
> > val it = true: bool
<<HOL message: Created theory "registerMachine">>
<<HOL message: Defined type: "action">>
Definition has been stored under "regOf_def"
Definition has been stored under "inst_Val_def"
Definition has been stored under "inst_Dest_def"
<<HOL message: Defined type: "rm">>
Definition has been stored under "init_machine_def"
<<HOL warning: GrammarDeltas.revise_data: 
  Grammar-deltas:
    overload_on("run_machine_1_tupled")
  invalidated by DelConstant(registerMachine$run_machine_1_tupled)>>
Equations stored under "run_machine_1_def".
Induction stored under "run_machine_1_ind".
<<HOL message: Initialising SRW simpset ... done>>
Definition has been stored under "run_machine_def"
Definition has been stored under "rsf_def"
Definition has been stored under "RUN_def"
Definition has been stored under "conv_def"
Definition has been stored under "strip_state_def"
<<HOL message: inventing new type variable names: 'a>>
Definition has been stored under "opt_to_set_def"
Definition has been stored under "action_states_def"
Definition has been stored under "wfrm_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Equations stored under "const_def".
Induction stored under "const_ind".
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "identity_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "identity'_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "identity2_def"
Definition has been stored under "empty_def"
Definition has been stored under "empty'_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "transfer_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "double_def"
Definition has been stored under "correct1_def"
Definition has been stored under "correct2_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "dup0_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "dup_def"
Definition has been stored under "rInst_def"
Definition has been stored under "mrInst_def"
Definition has been stored under "sInst_def"
Definition has been stored under "msInst_def"
<<HOL message: inventing new type variable names: 'a>>
Definition has been stored under "upd_def"
Definition has been stored under "end_link_def"
<<HOL message: inventing new type variable names: 'a>>
Definition has been stored under "linktf_def"
Definition has been stored under "link_def"
Definition has been stored under "link_all_def"
Definition has been stored under "correct_def"
Definition has been stored under "run_step_def"
metis: r[+0+4]#
Definition has been stored under "rmcorr_def"
Definition has been stored under "rm_ends_def"
Definition has been stored under "simp_add_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "simp_sub_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "addition_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "multiplication_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "exponential_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "factorial_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "Pi_def"
Definition has been stored under "Cn_def"
Definition has been stored under "loopguard"
Definition has been stored under "count"
Definition has been stored under "Pr_def"
Definition has been stored under "add1_def"
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
Definition has been stored under "id_def"
<<HOL message: inventing new type variable names: 'a>>
metis: r[+0+12]+0+0+0+0+0+0+0+0+0+0+0+3+2#
metis: r[+0+13]+0+0+0+0+0+0+0+0+0+0+0+0+3+2#
metis: r[+0+13]+0+0+0+0+0+0+0+1#
metis: r[+0+14]+0+0+0+0+0+0+0+0+0+0+0+0+0+4+1+2#
metis: r[+0+11]+0+0+0+0+0+0+0+1+0+1+1+0+0+1+1+1+1+1#
metis: r[+0+10]+0+0+0+0+0+0+0+1+0+1+1+0+1+1+5+2#
metis: r[+0+13]+0+0+0+0+0+0+0+0+0+0+0+0+1+1#
metis: r[+0+13]+0+0+0+0+0+0+0+0+0+0+0+0+1+1#
<<HOL message: inventing new type variable names: 'a>>
Definition has been stored under "rs_mrInst_B4_def"
<<HOL message: inventing new type variable names: 'a>>
Definition has been stored under "rs_mrInst_Aft_def"
metis: r[+0+7]+0+0+0+0+1+0+1+1+1+2+1+1+7#
metis: r[+0+6]#
metis: r[+0+7]+0+0+0+1+1+0+1+0+1+1+1+2+1+1+8#
metis: r[+0+6]#
metis: r[+0+9]+0+0+0+0+0+0+0+2+1+0+2+1+0+2+0+0+3#
metis: r[+0+17]+0+0+0+0+0+0+0+0+1+0+0+0+5+0+4+5+4+0+0+2+1+7#
metis: r[+0+13]#
metis: r[+0+13]+0+0+0+0+0+0+0+0+0+0+2+0+3+2#
<<HOL message: inventing new type variable names: 'a, 'b>>
Definition has been stored under "liftP_def"
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#
metis: metis: r[+0+5]#
<<HOL message: inventing new type variable names: 'a>>
Definition has been stored under "liftP_V_def"
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#
metis: metis: r[+0+5]#
Definition has been stored under "npair_opt_def"
metis: r[+0+7]+0+0+0+1+0+0+1+1+1+3#
metis: r[+0+7]+0+0+0+0+0+3#
metis: r[+0+8]+0+0+1+1+1+0+0+1+2+0+1+0+2+2+1+0+1+2+0+0+1+2+2+0+1+1+2+1+0+2+14#
metis: r[+0+8]+0+0+0+1+2#
metis: r[+0+6]#
metis: r[+0+6]#
metis: r[+0+5]#
metis: r[+0+5]#
metis: r[+0+5]#
metis: r[+0+5]#
metis: r[+0+6]#
metis: r[+0+11]+0+0+0+0+0+0+0+0+0+0+4+2#
metis: r[+0+13]+0+0+0+0+0+0+0+0+0+0+5+13+1+10+3+2+2+9+3+1+4+42+6+4+17+27+29+19+20+32+2+26+26+24+36+80+18+36+12+11+18+46+10+2#
metis: r[+0+8]+0+0+0+0+0+0+0+2+1+1+1#
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "lst_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "Tri_def"
<<HOL message: mk_functional: 
  pattern completion has added 1 clause to the original specification.>>
Definition has been stored under "invTri_def"
metis: r[+0+6]#
Definition has been stored under "Pair_def"
Definition has been stored under "FST_def"
Definition has been stored under "SND_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
metis: r[+0+5]+0+0+0+0+1#
r[+0+5]+0+0+0+1#
r[+0+5]+0+0+0+0+1#
r[+0+5]+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1+0+1+1+0+0+11+4+1+4+0+4+0+2+1+1+1+2+1+1+2+1+1+6+2+1+1+1+1+1+14+2+2+1+1+2+1+1+6+5+2+1+1+1+1+6+5+2+1+1+1+1+6+5+2+1+1+1+1+6+5+2+1+1+1+1+13+13+4+2+2+1+1+4+2+2+1+1+4+2+2+1+1+4+2+2+1+1+7+4+8+0+0+0+0+0+0+0+8+1+0+0+0+0+0+0+13+11+0+11+1#
> # <<HOL warning: ThmSetData.revise_data: 
  Theorems in set "simp":
    ADD<registerMachine.exp_facts>
  invalidated by NewBinding(exp_facts)>>
val exp_facts =
   ⊢ exponential.In = [1; 0] ∧ exponential.Out = 2 ∧ exponential.q0 = 14 ∧
     exponential.Q = {1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14} ∧
     exponential.tf 1 = Dec 0 (SOME 2) NONE ∧
     exponential.tf 2 = Dec 1 (SOME 3) (SOME 9) ∧
     exponential.tf 3 = Inc 5 (SOME 4) ∧
     exponential.tf 4 = Dec 2 (SOME 5) (SOME 7) ∧
     exponential.tf 5 = Inc 3 (SOME 6) ∧ exponential.tf 6 = Inc 4 (SOME 4) ∧
     exponential.tf 7 = Dec 4 (SOME 8) (SOME 2) ∧
     exponential.tf 8 = Inc 2 (SOME 7) ∧
     exponential.tf 9 = Dec 5 (SOME 10) (SOME 11) ∧
     exponential.tf 10 = Inc 1 (SOME 9) ∧
     exponential.tf 11 = Dec 2 (SOME 11) (SOME 12) ∧
     exponential.tf 12 = Dec 3 (SOME 13) (SOME 1) ∧
     exponential.tf 13 = Inc 2 (SOME 12) ∧ exponential.tf 14 = Inc 2 (SOME 1):
   thm
> > # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀RS.
            RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
            rmcorr exponential 14 (λrs. rs = RS) NONE
              (λrs.
                   rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                   ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   : proofs
> # > OK..
val it = There are currently no proofs.: proofs
> > # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀RS.
            RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
            rmcorr exponential 14 (λrs. rs = RS) NONE
              (λrs.
                   rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                   ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   : proofs
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs. rs⦇2 ↦ rs 2 − 1⦈ = RS ∧ 0 < rs 2 ⇒ INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 0 = 0 ⇒
                 rs 2 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 2 (λrs. INV rs⦇0 ↦ rs 0 + 1⦈ ∧ rs 0 = N)
                  (SOME 1) (λrs'. INV rs' ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs⦇2 ↦ rs 2 − 1⦈ = RS ∧ 0 < rs 2 ⇒
             (λrs.
                  rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 0 = 0 ⇒
             rs 2 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 2
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇0 ↦ rs 0 + 1⦈ ∧
                   rs 0 = N') (SOME 1)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 0 ≤ N')
   
   : proof
> > # OK..
5 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 0 + 1 = N ∧ rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N') (SOME 1)
          (λrs'.
               (rs' 0 = N ∧ rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k
    6.  rs 0 = 0
   ------------------------------------
        rs 2 = RS 1 ** RS 0
   
    0.  rs⦇2 ↦ rs 2 − 1⦈ 2 = 0
    1.  rs⦇2 ↦ rs 2 − 1⦈ 3 = 0
    2.  rs⦇2 ↦ rs 2 − 1⦈ 4 = 0
    3.  rs⦇2 ↦ rs 2 − 1⦈ 5 = 0
    4.  0 < rs 2
    5.  k ≠ 0
    6.  k ≠ 2
   ------------------------------------
        rs k = rs⦇2 ↦ rs 2 − 1⦈ k
   
    0.  rs⦇2 ↦ rs 2 − 1⦈ 2 = 0
    1.  rs⦇2 ↦ rs 2 − 1⦈ 3 = 0
    2.  rs⦇2 ↦ rs 2 − 1⦈ 4 = 0
    3.  rs⦇2 ↦ rs 2 − 1⦈ 5 = 0
    4.  0 < rs 2
   ------------------------------------
        rs 2 * rs 1 ** rs 0 = rs⦇2 ↦ rs 2 − 1⦈ 1 ** rs⦇2 ↦ rs 2 − 1⦈ 0
   
    0.  rs⦇2 ↦ rs 2 − 1⦈ 2 = 0
    1.  rs⦇2 ↦ rs 2 − 1⦈ 3 = 0
    2.  rs⦇2 ↦ rs 2 − 1⦈ 4 = 0
    3.  rs⦇2 ↦ rs 2 − 1⦈ 5 = 0
    4.  0 < rs 2
   ------------------------------------
        rs 0 = N

5 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  rs⦇2 ↦ rs 2 − 1⦈ 2 = 0
    1.  rs⦇2 ↦ rs 2 − 1⦈ 3 = 0
    2.  rs⦇2 ↦ rs 2 − 1⦈ 4 = 0
    3.  rs⦇2 ↦ rs 2 − 1⦈ 5 = 0
    4.  0 < rs 2
    5.  rs 2 = 1
   ------------------------------------
        rs 0 = N
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 0 + 1 = N ∧ rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N') (SOME 1)
          (λrs'.
               (rs' 0 = N ∧ rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k
    6.  rs 0 = 0
   ------------------------------------
        rs 2 = RS 1 ** RS 0
   
    0.  rs⦇2 ↦ rs 2 − 1⦈ 2 = 0
    1.  rs⦇2 ↦ rs 2 − 1⦈ 3 = 0
    2.  rs⦇2 ↦ rs 2 − 1⦈ 4 = 0
    3.  rs⦇2 ↦ rs 2 − 1⦈ 5 = 0
    4.  0 < rs 2
    5.  k ≠ 0
    6.  k ≠ 2
   ------------------------------------
        rs k = rs⦇2 ↦ rs 2 − 1⦈ k
   
    0.  rs⦇2 ↦ rs 2 − 1⦈ 2 = 0
    1.  rs⦇2 ↦ rs 2 − 1⦈ 3 = 0
    2.  rs⦇2 ↦ rs 2 − 1⦈ 4 = 0
    3.  rs⦇2 ↦ rs 2 − 1⦈ 5 = 0
    4.  0 < rs 2
   ------------------------------------
        rs 2 * rs 1 ** rs 0 = rs⦇2 ↦ rs 2 − 1⦈ 1 ** rs⦇2 ↦ rs 2 − 1⦈ 0
   
    0.  rs⦇2 ↦ rs 2 − 1⦈ 2 = 0
    1.  rs⦇2 ↦ rs 2 − 1⦈ 3 = 0
    2.  rs⦇2 ↦ rs 2 − 1⦈ 4 = 0
    3.  rs⦇2 ↦ rs 2 − 1⦈ 5 = 0
    4.  0 < rs 2
   ------------------------------------
        rs 0 = N

5 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs⦇2 ↦ rs 2 − 1⦈ = RS ∧ 0 < rs 2 ⇒
             (λrs.
                  rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 0 = 0 ⇒
             rs 2 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 2
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇0 ↦ rs 0 + 1⦈ ∧
                   rs 0 = N') (SOME 1)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 0 ≤ N')
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs. rs⦇2 ↦ rs 2 − 1⦈ = RS ∧ 0 < rs 2 ⇒ INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 0 = 0 ⇒
                 rs 2 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 2 (λrs. INV rs⦇0 ↦ rs 0 + 1⦈ ∧ rs 0 = N)
                  (SOME 1) (λrs'. INV rs' ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs⦇2 ↦ rs 2 − 1⦈ = RS ∧ 0 < rs 2 ⇒
             (λrs.
                  rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 0 = 0 ⇒
             rs 2 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
        ∀N.
            rmcorr exponential 2
              (λrs.
                   (λrs.
                        rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇0 ↦ rs 0 + 1⦈ ∧
                   rs 0 = N) (SOME 1)
              (λrs'.
                   (λrs.
                        rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 0 ≤ N)
   
   : proof
> > # # # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃Q q2.
            rmcorr exponential 2
              (λrs.
                   (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME q2) Q ∧
            rmcorr exponential q2 Q (SOME 1)
              (λrs'.
                   (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 1 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) ∧
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 1 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 1 = 0 ⇒
                 rs 0 = N ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧ rs 3 = 0 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 3 (λrs. INV rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N)
                  (SOME 2) (λrs'. INV rs' ∧ rs' 1 ≤ N)
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 1 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) ∧
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 1 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 1 = 0 ⇒
                 rs 0 = N ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧ rs 3 = 0 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 3 (λrs. INV rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N)
                  (SOME 2) (λrs'. INV rs' ∧ rs' 1 ≤ N)
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 1 = 0 ⇒
                 rs 0 = N ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧ rs 3 = 0 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 3 (λrs. INV rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N)
                  (SOME 2) (λrs'. INV rs' ∧ rs' 1 ≤ N)
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 1 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) ∧
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 2 * rs 5 ** rs 0 = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 1 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃Q q2.
            rmcorr exponential 2
              (λrs.
                   (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME q2) Q ∧
            rmcorr exponential q2 Q (SOME 1)
              (λrs'.
                   (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 5 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) ∧
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * rs 5 ∧ ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 2
          (λrs.
               (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 1 = 0 ⇒
                 rs 0 = N ∧ rs 5 = RS 1 ∧
                 rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 = rs 5 * rs 2 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 3 (λrs. INV rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N)
                  (SOME 2) (λrs'. INV rs' ∧ rs' 1 ≤ N)
   
   : proof
> > # # # OK..

Exception raised at Tactic.MATCH_MP_TAC:
No match
Exception-
   HOL_ERR
     {message = "No match", origin_function = "MATCH_MP_TAC",
      origin_structure = "Tactic"} raised
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs ∧ rs 1 = 0 ⇒
             rs 0 = N ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 3
              (λrs.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs⦇1 ↦ rs 1 + 1⦈ ∧
                   rs 1 = N') (SOME 2)
              (λrs'.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs' ∧ rs' 1 ≤ N')
   
   : proof
> > # OK..
5 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * (RS 1 ** rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0

5 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs ∧ rs 1 = 0 ⇒
             rs 0 = N ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 3
              (λrs.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs⦇1 ↦ rs 1 + 1⦈ ∧
                   rs 1 = N') (SOME 2)
              (λrs'.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * (RS 1 ** rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs' ∧ rs' 1 ≤ N')
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 1 = 0 ⇒
                 rs 0 = N ∧ rs 5 = RS 1 ∧
                 rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 = rs 5 * rs 2 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 3 (λrs. INV rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N)
                  (SOME 2) (λrs'. INV rs' ∧ rs' 1 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs ∧ rs 1 = 0 ⇒
             rs 0 = N ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 3
              (λrs.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs⦇1 ↦ rs 1 + 1⦈ ∧
                   rs 1 = N') (SOME 2)
              (λrs'.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs' ∧ rs' 1 ≤ N')
   
   : proof
> > # OK..
5 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs⦇1 ↦ rs 1 + 1⦈ 1 + rs⦇1 ↦ rs 1 + 1⦈ 5 = RS 1 ∧
                rs⦇1 ↦ rs 1 + 1⦈ 0 = N ∧
                RS 1 ** (rs⦇1 ↦ rs 1 + 1⦈ 0 + 1) * rs⦇1 ↦ rs 1 + 1⦈ 2 =
                RS 1 ** RS 0 ∧ rs⦇1 ↦ rs 1 + 1⦈ 4 = 0 ∧
                rs⦇1 ↦ rs 1 + 1⦈ 1 * rs⦇1 ↦ rs 1 + 1⦈ 2 + rs⦇1 ↦ rs 1 + 1⦈ 3 =
                RS 1 * rs⦇1 ↦ rs 1 + 1⦈ 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

5 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs ∧ rs 1 = 0 ⇒
             rs 0 = N ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 3
              (λrs.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs⦇1 ↦ rs 1 + 1⦈ ∧
                   rs 1 = N') (SOME 2)
              (λrs'.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs' ∧ rs' 1 ≤ N')
   
   : proof
> > # OK..
5 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

5 subgoals
   : proof
> > # OK..
metis: r[+0+8]+0+0+0+0+0+0+0+5+4+1+0+0+0+3+1+18+3+3+2+1+2+2+2+2+3+3+3+3+3+2+3+2+1+2+1+1+0+2+1+1+2+2+1+1+2+1+0+1+1+0+1+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> > # OK..

Goal proved.
 [......] ⊢ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0

4 subgoals
   : proof
> > # OK..

Goal proved.
 [.........] ⊢ rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2

3 subgoals
   : proof
> > # OK..

Goal proved.
 [.........] ⊢ rs 3 = rs 5 * rs 2

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2

3 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0

4 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2) ∧ rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2) ∧ rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 3 = rs 5 * rs 2
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 4 = 0
    7.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    8.  rs 1 = 0
   ------------------------------------
        rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

5 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs ∧ rs 1 = 0 ⇒
             rs 0 = N ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 3
              (λrs.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs⦇1 ↦ rs 1 + 1⦈ ∧
                   rs 1 = N') (SOME 2)
              (λrs'.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2) rs' ∧ rs' 1 ≤ N')
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 1 = 0 ⇒
                 rs 0 = N ∧ rs 5 = RS 1 ∧
                 rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 = rs 5 * rs 2 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 3 (λrs. INV rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N)
                  (SOME 2) (λrs'. INV rs' ∧ rs' 1 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs ∧ rs 1 = 0 ⇒
             rs 0 = N ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 3
              (λrs.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
                        ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k)
                     rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N') (SOME 2)
              (λrs'.
                   (λrs.
                        rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                        rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
                        ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs' ∧
                   rs' 1 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 3
          (λrs.
               (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
                rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
               rs 1 = N') (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 1 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 4
          (λrs.
               ((rs⦇5 ↦ rs 5 − 1⦈ 1 + (rs⦇5 ↦ rs 5 − 1⦈ 5 + 1) = RS 1 ∧
                 rs⦇5 ↦ rs 5 − 1⦈ 0 = N ∧
                 RS 1 ** (rs⦇5 ↦ rs 5 − 1⦈ 0 + 1) * rs⦇5 ↦ rs 5 − 1⦈ 2 =
                 RS 1 ** RS 0 ∧ rs⦇5 ↦ rs 5 − 1⦈ 4 = 0 ∧
                 (rs⦇5 ↦ rs 5 − 1⦈ 1 + 1) * rs⦇5 ↦ rs 5 − 1⦈ 2 +
                 rs⦇5 ↦ rs 5 − 1⦈ 3 =
                 RS 1 * rs⦇5 ↦ rs 5 − 1⦈ 2 ∧
                 ∀k.
                     k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒
                     rs⦇5 ↦ rs 5 − 1⦈ k = RS k) ∧ rs⦇5 ↦ rs 5 − 1⦈ 1 = N') ∧
               0 < rs 5) (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 1 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 4
          (λrs.
               ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
                 rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                 rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
                rs 1 = N') ∧ 0 < rs 5) (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 1 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃Q q2.
            rmcorr exponential 4
              (λrs.
                   ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
                     rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                     rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
                     ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
                    rs 1 = N') ∧ 0 < rs 5) (SOME q2) Q ∧
            rmcorr exponential q2 Q (SOME 2)
              (λrs'.
                   (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                    rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                    rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
                   rs' 1 ≤ N')
   
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 4
          (λrs.
               ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
                 rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                 rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
                rs 1 = N') ∧ 0 < rs 5) (SOME 7)
          (λrs.
               rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
               rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
               ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) ∧
        rmcorr exponential 7
          (λrs.
               rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
               rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
               ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 1 ≤ N')
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 7
          (λrs.
               rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
               rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
               ∀k.
                   k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                   rs k = RS k) (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 1 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 4
          (λrs.
               ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
                 rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                 rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
                rs 1 = N') ∧ 0 < rs 5) (SOME 7)
          (λrs.
               rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
               rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
               ∀k.
                   k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                   rs k = RS k)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
                   rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                   rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
                   ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
                  rs 1 = N') ∧ 0 < rs 5 ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 2 = 0 ⇒
                 rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                 rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
                 ∀k.
                     k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                     rs k = RS k) ∧
            ∀N.
                rmcorr exponential 5 (λrs. INV rs⦇2 ↦ rs 2 + 1⦈ ∧ rs 2 = N)
                  (SOME 4) (λrs'. INV rs' ∧ rs' 2 ≤ N)
   
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
               rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
               rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
              rs 1 = N') ∧ 0 < rs 5 ⇒
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs ∧ rs 2 = 0 ⇒
             rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
             rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        ∀N''.
            rmcorr exponential 5
              (λrs.
                   (λrs.
                        rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                        (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) =
                        RS 1 * (rs 2 + rs 4) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k)
                     rs⦇2 ↦ rs 2 + 1⦈ ∧ rs 2 = N'') (SOME 4)
              (λrs'.
                   (λrs.
                        rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                        (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) =
                        RS 1 * (rs 2 + rs 4) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs' ∧
                   rs' 2 ≤ N'')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 5
          (λrs.
               (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 + (rs 2 + (rs 1 * (rs 2 + (rs 4 + 1)) + 1)) =
                RS 1 * (rs 2 + (rs 4 + 1)) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs k = RS k) ∧ rs 2 = N'') (SOME 4)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) =
                RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 2 ≤ N'')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 6
          (λrs.
               ((rs⦇3 ↦ rs 3 − 1⦈ 1 = N' ∧ rs⦇3 ↦ rs 3 − 1⦈ 0 = N ∧
                 rs⦇3 ↦ rs 3 − 1⦈ 1 + rs⦇3 ↦ rs 3 − 1⦈ 5 = RS 1 ∧
                 (rs⦇3 ↦ rs 3 − 1⦈ 2 + (rs⦇3 ↦ rs 3 − 1⦈ 4 + 1)) *
                 RS 1 ** (rs⦇3 ↦ rs 3 − 1⦈ 0 + 1) =
                 RS 1 ** RS 0 ∧
                 (rs⦇3 ↦ rs 3 − 1⦈ 2 + (rs⦇3 ↦ rs 3 − 1⦈ 4 + 1)) *
                 rs⦇3 ↦ rs 3 − 1⦈ 1 +
                 (rs⦇3 ↦ rs 3 − 1⦈ 3 + (rs⦇3 ↦ rs 3 − 1⦈ 2 + 1)) =
                 RS 1 * (rs⦇3 ↦ rs 3 − 1⦈ 2 + (rs⦇3 ↦ rs 3 − 1⦈ 4 + 1)) ∧
                 ∀k.
                     k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                     rs⦇3 ↦ rs 3 − 1⦈ k = RS k) ∧ rs⦇3 ↦ rs 3 − 1⦈ 2 = N'') ∧
               0 < rs 3) (SOME 4)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) =
                RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 2 ≤ N'')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 4
          (λrs.
               (((rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 1 = N' ∧
                  rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 0 = N ∧
                  rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 1 +
                  rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 5 =
                  RS 1 ∧
                  (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 +
                   (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 4 + 1)) *
                  RS 1 **
                  (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 0 + 1) =
                  RS 1 ** RS 0 ∧
                  (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 +
                   (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 4 + 1)) *
                  rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 1 +
                  (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 3 +
                   (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 + 1)) =
                  RS 1 *
                  (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 +
                   (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 4 + 1)) ∧
                  ∀k.
                      k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                      rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ k = RS k) ∧
                 rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 = N'') ∧
                0 < rs⦇4 ↦ rs 4 − 1⦈ 3) ∧ 0 < rs 4) (SOME 4)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) =
                RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 2 ≤ N'')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 4
          (λrs.
               (((rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + (rs 4 − 1 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 1 * (rs 2 + (rs 4 − 1 + 1)) + (rs 3 − 1 + (rs 2 + 1)) =
                  RS 1 * (rs 2 + (rs 4 − 1 + 1)) ∧
                  ∀k.
                      k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                      rs k = RS k) ∧ rs 2 = N'') ∧ 0 < rs 3) ∧ 0 < rs 4)
          (SOME 4)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) =
                RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 2 ≤ N'')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∀rs.
            (((rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               (rs 2 + (rs 4 − 1 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 1 * (rs 2 + (rs 4 − 1 + 1)) + (rs 3 − 1 + (rs 2 + 1)) =
               RS 1 * (rs 2 + (rs 4 − 1 + 1)) ∧
               ∀k.
                   k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                   rs k = RS k) ∧ rs 2 = N'') ∧ 0 < rs 3) ∧ 0 < rs 4 ⇒
            (N'' + rs 4) * RS 1 ** (N + 1) = RS 1 ** RS 0 ∧
            N'' + (rs 3 + N' * (N'' + rs 4)) = RS 1 * (N'' + rs 4)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 + (rs 4 − 1 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 1 * (rs 2 + (rs 4 − 1 + 1)) + (rs 3 − 1 + (rs 2 + 1)) =
        RS 1 * (rs 2 + (rs 4 − 1 + 1))
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  0 < rs 3
    9.  0 < rs 4
   ------------------------------------
        rs 2 + (rs 3 + rs 1 * (rs 2 + rs 4)) = RS 1 * (rs 2 + rs 4)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 + (rs 4 − 1 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 1 * (rs 2 + (rs 4 − 1 + 1)) + (rs 3 − 1 + (rs 2 + 1)) =
        RS 1 * (rs 2 + (rs 4 − 1 + 1))
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  0 < rs 3
    9.  0 < rs 4
   ------------------------------------
        (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

2 subgoals
   : proof
> > # OK..

Goal proved.
 [.......] ⊢ (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 + (rs 4 − 1 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 1 * (rs 2 + (rs 4 − 1 + 1)) + (rs 3 − 1 + (rs 2 + 1)) =
        RS 1 * (rs 2 + (rs 4 − 1 + 1))
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  0 < rs 3
    9.  0 < rs 4
   ------------------------------------
        rs 2 + (rs 3 + rs 1 * (rs 2 + rs 4)) = RS 1 * (rs 2 + rs 4)
   
   : proof
> > # OK..

Goal proved.
 [..........] ⊢ rs 2 + (rs 3 + rs 1 * (rs 2 + rs 4)) = RS 1 * (rs 2 + rs 4)

Goal proved.
 [....]
⊢ ∀rs.
      (((rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
         (rs 2 + (rs 4 − 1 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
         rs 1 * (rs 2 + (rs 4 − 1 + 1)) + (rs 3 − 1 + (rs 2 + 1)) =
         RS 1 * (rs 2 + (rs 4 − 1 + 1)) ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        rs 2 = N'') ∧ 0 < rs 3) ∧ 0 < rs 4 ⇒
      (N'' + rs 4) * RS 1 ** (N + 1) = RS 1 ** RS 0 ∧
      N'' + (rs 3 + N' * (N'' + rs 4)) = RS 1 * (N'' + rs 4)

Goal proved.
 [....]
⊢ rmcorr exponential 4
    (λrs.
         (((rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
            (rs 2 + (rs 4 − 1 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 1 * (rs 2 + (rs 4 − 1 + 1)) + (rs 3 − 1 + (rs 2 + 1)) =
            RS 1 * (rs 2 + (rs 4 − 1 + 1)) ∧
            ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
           rs 2 = N'') ∧ 0 < rs 3) ∧ 0 < rs 4) (SOME 4)
    (λrs'.
         (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) = RS 1 * (rs' 2 + rs' 4) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 2 ≤ N'')

Goal proved.
 [....]
⊢ rmcorr exponential 4
    (λrs.
         (((rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 1 = N' ∧
            rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 0 = N ∧
            rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 1 +
            rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 5 =
            RS 1 ∧
            (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 +
             (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 4 + 1)) *
            RS 1 ** (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 0 + 1) =
            RS 1 ** RS 0 ∧
            (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 +
             (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 4 + 1)) *
            rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 1 +
            (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 3 +
             (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 + 1)) =
            RS 1 *
            (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 +
             (rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 4 + 1)) ∧
            ∀k.
                k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ k = RS k) ∧
           rs⦇3 ↦ rs⦇4 ↦ rs 4 − 1⦈ 3 − 1; 4 ↦ rs 4 − 1⦈ 2 = N'') ∧
          0 < rs⦇4 ↦ rs 4 − 1⦈ 3) ∧ 0 < rs 4) (SOME 4)
    (λrs'.
         (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) = RS 1 * (rs' 2 + rs' 4) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 2 ≤ N'')

Goal proved.
 [....]
⊢ rmcorr exponential 6
    (λrs.
         ((rs⦇3 ↦ rs 3 − 1⦈ 1 = N' ∧ rs⦇3 ↦ rs 3 − 1⦈ 0 = N ∧
           rs⦇3 ↦ rs 3 − 1⦈ 1 + rs⦇3 ↦ rs 3 − 1⦈ 5 = RS 1 ∧
           (rs⦇3 ↦ rs 3 − 1⦈ 2 + (rs⦇3 ↦ rs 3 − 1⦈ 4 + 1)) *
           RS 1 ** (rs⦇3 ↦ rs 3 − 1⦈ 0 + 1) =
           RS 1 ** RS 0 ∧
           (rs⦇3 ↦ rs 3 − 1⦈ 2 + (rs⦇3 ↦ rs 3 − 1⦈ 4 + 1)) *
           rs⦇3 ↦ rs 3 − 1⦈ 1 +
           (rs⦇3 ↦ rs 3 − 1⦈ 3 + (rs⦇3 ↦ rs 3 − 1⦈ 2 + 1)) =
           RS 1 * (rs⦇3 ↦ rs 3 − 1⦈ 2 + (rs⦇3 ↦ rs 3 − 1⦈ 4 + 1)) ∧
           ∀k.
               k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
               rs⦇3 ↦ rs 3 − 1⦈ k = RS k) ∧ rs⦇3 ↦ rs 3 − 1⦈ 2 = N'') ∧
         0 < rs 3) (SOME 4)
    (λrs'.
         (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) = RS 1 * (rs' 2 + rs' 4) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 2 ≤ N'')

Goal proved.
 [....]
⊢ rmcorr exponential 5
    (λrs.
         (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
          (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
          rs 3 + (rs 2 + (rs 1 * (rs 2 + (rs 4 + 1)) + 1)) =
          RS 1 * (rs 2 + (rs 4 + 1)) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
         rs 2 = N'') (SOME 4)
    (λrs'.
         (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 + (rs' 2 + rs' 1 * (rs' 2 + rs' 4)) = RS 1 * (rs' 2 + rs' 4) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 2 ≤ N'')

Goal proved.
 [....]
⊢ (∀rs.
       ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
         rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
         rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
        rs 1 = N') ∧ 0 < rs 5 ⇒
       (λrs.
            rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
            (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
            ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs) ∧
  (∀rs.
       (λrs.
            rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
            (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
            ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs ∧ rs 2 = 0 ⇒
       rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
       rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
       rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
       ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
  ∀N''.
      rmcorr exponential 5
        (λrs.
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs⦇2 ↦ rs 2 + 1⦈ ∧
             rs 2 = N'') (SOME 4)
        (λrs'.
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 2 + rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs' ∧ rs' 2 ≤ N'')

Goal proved.
 [....]
⊢ ∃INV.
      (∀rs.
           ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
             rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
             rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            rs 1 = N') ∧ 0 < rs 5 ⇒
           INV rs) ∧
      (∀rs.
           INV rs ∧ rs 2 = 0 ⇒
           rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
           rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
           rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
           ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
      ∀N.
          rmcorr exponential 5 (λrs. INV rs⦇2 ↦ rs 2 + 1⦈ ∧ rs 2 = N)
            (SOME 4) (λrs'. INV rs' ∧ rs' 2 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 4
    (λrs.
         ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
           rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
           rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
           ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
          rs 1 = N') ∧ 0 < rs 5) (SOME 7)
    (λrs.
         rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
         rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
         rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k)

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 7
          (λrs.
               rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
               rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
               ∀k.
                   k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                   rs k = RS k) (SOME 2)
          (λrs'.
               (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
                rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
                rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 1 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                 rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
                 rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
                 (∀k.
                      k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                      rs k = RS k) ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 4 = 0 ⇒
                 (rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
                 rs 1 ≤ N') ∧
            ∀N.
                rmcorr exponential 8 (λrs. INV rs⦇4 ↦ rs 4 + 1⦈ ∧ rs 4 = N)
                  (SOME 7) (λrs'. INV rs' ∧ rs' 4 ≤ N)
   
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
             rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
             rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
             (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs ∧ rs 4 = 0 ⇒
             (rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
              rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
              ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
             rs 1 ≤ N') ∧
        ∀N''.
            rmcorr exponential 8
              (λrs.
                   (λrs.
                        rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                        (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k)
                     rs⦇4 ↦ rs 4 + 1⦈ ∧ rs 4 = N'') (SOME 7)
              (λrs'.
                   (λrs.
                        rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                        (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs' ∧
                   rs' 4 ≤ N'')
   
   : proof
> > # OK..
6 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 8
          (λrs.
               (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 + rs 1 * (rs 2 + (rs 4 + 1)) =
                RS 1 * (rs 2 + (rs 4 + 1)) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs k = RS k) ∧ rs 4 = N'') (SOME 7)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 4 ≤ N'')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4)
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4)
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
   ------------------------------------
        rs 3 + rs 1 * rs 2 = RS 1 * rs 2
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4)
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 2 = 0
    7.  rs 3 + rs 1 * rs 4 = RS 1 * rs 4
    8.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
   ------------------------------------
        rs 3 + rs 1 * rs 4 = RS 1 * rs 4
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 2 = 0
    7.  rs 3 + rs 1 * rs 4 = RS 1 * rs 4
    8.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
   ------------------------------------
        rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

6 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
             rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
             rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
             (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs ∧ rs 4 = 0 ⇒
             (rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
              rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
              ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
             rs 1 ≤ N') ∧
        ∀N''.
            rmcorr exponential 8
              (λrs.
                   (λrs.
                        rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                        (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k)
                     rs⦇4 ↦ rs 4 + 1⦈ ∧ rs 4 = N'') (SOME 7)
              (λrs'.
                   (λrs.
                        rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                        (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs' ∧
                   rs' 4 ≤ N'')
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 8
          (λrs.
               (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 + rs 1 * (rs 2 + (rs 4 + 1)) =
                RS 1 * (rs 2 + (rs 4 + 1)) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs k = RS k) ∧ rs 4 = N'') (SOME 7)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 4 ≤ N'')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 8
          (λrs.
               (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 + rs 1 * (rs 2 + (rs 4 + 1)) =
                RS 1 * (rs 2 + (rs 4 + 1)) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs k = RS k) ∧ rs 4 = N'') (SOME 7)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 4 ≤ N'')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 8
          (λrs.
               (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 + rs 1 * (rs 2 + (rs 4 + 1)) =
                RS 1 * (rs 2 + (rs 4 + 1)) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs k = RS k) ∧ rs 4 = N'') (SOME 7)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 4 ≤ N'')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  rs 4 = 0
    8.  k ≠ 0
    9.  k ≠ 1
   10.  k ≠ 2
   11.  k ≠ 3
   12.  k ≠ 5
   ------------------------------------
        k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 3 ∧ k ≠ 5 ∧ k ≠ 2 ∧ k ≠ 4
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  rs 4 = 0
    8.  k ≠ 0
    9.  k ≠ 1
   10.  k ≠ 2
   11.  k ≠ 3
   12.  k ≠ 5
   ------------------------------------
        k ≠ 4
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  rs 4 = 0
    8.  k ≠ 0
    9.  k ≠ 1
   10.  k ≠ 2
   11.  k ≠ 3
   12.  k ≠ 5
   ------------------------------------
        k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 3 ∧ k ≠ 5 ∧ k ≠ 2 ∧ k ≠ 4
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 8
          (λrs.
               (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 + rs 1 * (rs 2 + (rs 4 + 1)) =
                RS 1 * (rs 2 + (rs 4 + 1)) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs k = RS k) ∧ rs 4 = N'') (SOME 7)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 4 ≤ N'')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * rs 2 = RS 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 4 = 0
    9.  k ≠ 0
   10.  k ≠ 1
   11.  k ≠ 2
   12.  k ≠ 3
   13.  k ≠ 5
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..

Goal proved.
 [..............] ⊢ rs k = RS k

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 8
          (λrs.
               (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 + rs 1 * (rs 2 + (rs 4 + 1)) =
                RS 1 * (rs 2 + (rs 4 + 1)) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs k = RS k) ∧ rs 4 = N'') (SOME 7)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 4 ≤ N'')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 7
          (λrs.
               ((rs⦇2 ↦ rs 2 − 1⦈ 1 = N' ∧ rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
                 rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 5 = RS 1 ∧
                 (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
                 RS 1 ** (rs⦇2 ↦ rs 2 − 1⦈ 0 + 1) =
                 RS 1 ** RS 0 ∧
                 (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
                 rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 3 =
                 RS 1 * (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) ∧
                 ∀k.
                     k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                     rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧ rs⦇2 ↦ rs 2 − 1⦈ 4 = N'') ∧
               0 < rs 2) (SOME 7)
          (λrs'.
               (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                    rs' k = RS k) ∧ rs' 4 ≤ N'')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∀rs.
            ((rs⦇2 ↦ rs 2 − 1⦈ 1 = N' ∧ rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
              rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 5 = RS 1 ∧
              (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
              RS 1 ** (rs⦇2 ↦ rs 2 − 1⦈ 0 + 1) =
              RS 1 ** RS 0 ∧
              (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
              rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 3 =
              RS 1 * (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) ∧
              ∀k.
                  k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                  rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧ rs⦇2 ↦ rs 2 − 1⦈ 4 = N'') ∧
            0 < rs 2 ⇒
            (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
             (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            rs 4 ≤ N''
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 − 1 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * (rs 2 − 1 + (rs 4 + 1)) =
        RS 1 * (rs 2 − 1 + (rs 4 + 1))
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  0 < rs 2
   ------------------------------------
        rs 3 + rs 1 * (rs 4 + rs 2) = RS 1 * (rs 4 + rs 2)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  (rs 2 − 1 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 + rs 1 * (rs 2 − 1 + (rs 4 + 1)) =
        RS 1 * (rs 2 − 1 + (rs 4 + 1))
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  0 < rs 2
   ------------------------------------
        (rs 4 + rs 2) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∀rs.
            ((rs⦇2 ↦ rs 2 − 1⦈ 1 = N' ∧ rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
              rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 5 = RS 1 ∧
              (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
              RS 1 ** (rs⦇2 ↦ rs 2 − 1⦈ 0 + 1) =
              RS 1 ** RS 0 ∧
              (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
              rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 3 =
              RS 1 * (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) ∧
              ∀k.
                  k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
                  rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧ rs⦇2 ↦ rs 2 − 1⦈ 4 = N'') ∧
            0 < rs 2 ⇒
            (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
             (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            rs 4 ≤ N''
   
   : proof
> > # OK..

Goal proved.
 [....]
⊢ ∀rs.
      ((rs⦇2 ↦ rs 2 − 1⦈ 1 = N' ∧ rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
        rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 5 = RS 1 ∧
        (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
        RS 1 ** (rs⦇2 ↦ rs 2 − 1⦈ 0 + 1) =
        RS 1 ** RS 0 ∧
        (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) * rs⦇2 ↦ rs 2 − 1⦈ 1 +
        rs⦇2 ↦ rs 2 − 1⦈ 3 =
        RS 1 * (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) ∧
        ∀k.
            k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
            rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧ rs⦇2 ↦ rs 2 − 1⦈ 4 = N'') ∧ 0 < rs 2 ⇒
      (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
       (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
       rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
       ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
      rs 4 ≤ N''

Goal proved.
 [....]
⊢ rmcorr exponential 7
    (λrs.
         ((rs⦇2 ↦ rs 2 − 1⦈ 1 = N' ∧ rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
           rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 5 = RS 1 ∧
           (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
           RS 1 ** (rs⦇2 ↦ rs 2 − 1⦈ 0 + 1) =
           RS 1 ** RS 0 ∧
           (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) *
           rs⦇2 ↦ rs 2 − 1⦈ 1 + rs⦇2 ↦ rs 2 − 1⦈ 3 =
           RS 1 * (rs⦇2 ↦ rs 2 − 1⦈ 2 + (rs⦇2 ↦ rs 2 − 1⦈ 4 + 1)) ∧
           ∀k.
               k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒
               rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧ rs⦇2 ↦ rs 2 − 1⦈ 4 = N'') ∧
         0 < rs 2) (SOME 7)
    (λrs'.
         (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 4 ≤ N'')

Goal proved.
 [....]
⊢ rmcorr exponential 8
    (λrs.
         (rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
          (rs 2 + (rs 4 + 1)) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
          rs 3 + rs 1 * (rs 2 + (rs 4 + 1)) = RS 1 * (rs 2 + (rs 4 + 1)) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
         rs 4 = N'') (SOME 7)
    (λrs'.
         (rs' 1 = N' ∧ rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          (rs' 2 + rs' 4) * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 + rs' 1 * (rs' 2 + rs' 4) = RS 1 * (rs' 2 + rs' 4) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 4 ≤ N'')

Goal proved.
 [....]
⊢ (∀rs.
       rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
       rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
       rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
       (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
       (λrs.
            rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
            (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
            ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs) ∧
  (∀rs.
       (λrs.
            rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
            (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
            ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs ∧ rs 4 = 0 ⇒
       (rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
        rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
        ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧ rs 1 ≤ N') ∧
  ∀N''.
      rmcorr exponential 8
        (λrs.
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs⦇4 ↦ rs 4 + 1⦈ ∧
             rs 4 = N'') (SOME 7)
        (λrs'.
             (λrs.
                  rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
                  (rs 2 + rs 4) * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 + rs 1 * (rs 2 + rs 4) = RS 1 * (rs 2 + rs 4) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) rs' ∧ rs' 4 ≤ N'')

Goal proved.
 [....]
⊢ ∃INV.
      (∀rs.
           rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
           rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
           rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
           (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
           INV rs) ∧
      (∀rs.
           INV rs ∧ rs 4 = 0 ⇒
           (rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
            rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
            ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
           rs 1 ≤ N') ∧
      ∀N.
          rmcorr exponential 8 (λrs. INV rs⦇4 ↦ rs 4 + 1⦈ ∧ rs 4 = N)
            (SOME 7) (λrs'. INV rs' ∧ rs' 4 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 7
    (λrs.
         rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
         rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
         rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 4 ∧ k ≠ 5 ⇒ rs k = RS k)
    (SOME 2)
    (λrs'.
         (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
          rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
          rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 1 ≤ N')

Goal proved.
 [....]
⊢ rmcorr exponential 4
    (λrs.
         ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
           rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
           rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
           ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
          rs 1 = N') ∧ 0 < rs 5) (SOME 7)
    (λrs.
         rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
         rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
         rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
         ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) ∧
  rmcorr exponential 7
    (λrs.
         rs 1 = N' ∧ rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
         rs 4 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 2 = 0 ∧
         rs 3 + rs 1 * rs 4 = RS 1 * rs 4 ∧
         ∀k. k ∉ {0; 1; 2; 3; 4; 5} ⇒ rs k = RS k) (SOME 2)
    (λrs'.
         (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
          rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
          rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 1 ≤ N')

Goal proved.
 [....]
⊢ ∃Q q2.
      rmcorr exponential 4
        (λrs.
             ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
               rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
               rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
              rs 1 = N') ∧ 0 < rs 5) (SOME q2) Q ∧
      rmcorr exponential q2 Q (SOME 2)
        (λrs'.
             (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
              rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
              rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
              ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
             rs' 1 ≤ N')

Goal proved.
 [....]
⊢ rmcorr exponential 4
    (λrs.
         ((rs 1 + (rs 5 − 1 + 1) = RS 1 ∧ rs 0 = N ∧
           rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
           rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
           ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
          rs 1 = N') ∧ 0 < rs 5) (SOME 2)
    (λrs'.
         (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
          rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
          rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 1 ≤ N')

Goal proved.
 [....]
⊢ rmcorr exponential 4
    (λrs.
         ((rs⦇5 ↦ rs 5 − 1⦈ 1 + (rs⦇5 ↦ rs 5 − 1⦈ 5 + 1) = RS 1 ∧
           rs⦇5 ↦ rs 5 − 1⦈ 0 = N ∧
           RS 1 ** (rs⦇5 ↦ rs 5 − 1⦈ 0 + 1) * rs⦇5 ↦ rs 5 − 1⦈ 2 =
           RS 1 ** RS 0 ∧ rs⦇5 ↦ rs 5 − 1⦈ 4 = 0 ∧
           (rs⦇5 ↦ rs 5 − 1⦈ 1 + 1) * rs⦇5 ↦ rs 5 − 1⦈ 2 + rs⦇5 ↦ rs 5 − 1⦈ 3 =
           RS 1 * rs⦇5 ↦ rs 5 − 1⦈ 2 ∧
           ∀k.
               k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒
               rs⦇5 ↦ rs 5 − 1⦈ k = RS k) ∧ rs⦇5 ↦ rs 5 − 1⦈ 1 = N') ∧
         0 < rs 5) (SOME 2)
    (λrs'.
         (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
          rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
          rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 1 ≤ N')

Goal proved.
 [....]
⊢ rmcorr exponential 3
    (λrs.
         (rs 1 + (rs 5 + 1) = RS 1 ∧ rs 0 = N ∧
          rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
          rs 3 + rs 2 * (rs 1 + 1) = RS 1 * rs 2 ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
         rs 1 = N') (SOME 2)
    (λrs'.
         (rs' 1 + rs' 5 = RS 1 ∧ rs' 0 = N ∧
          rs' 2 * RS 1 ** (rs' 0 + 1) = RS 1 ** RS 0 ∧ rs' 4 = 0 ∧
          rs' 3 + rs' 1 * rs' 2 = RS 1 * rs' 2 ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 1 ≤ N')

Goal proved.
 [....]
⊢ (∀rs.
       (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
        ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
       (λrs.
            rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
            rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
            rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
            ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs) ∧
  (∀rs.
       (λrs.
            rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
            rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
            rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
            ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs ∧ rs 1 = 0 ⇒
       rs 0 = N ∧ rs 5 = RS 1 ∧ rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
       rs 3 = rs 5 * rs 2 ∧
       ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
  ∀N'.
      rmcorr exponential 3
        (λrs.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs⦇1 ↦ rs 1 + 1⦈ ∧
             rs 1 = N') (SOME 2)
        (λrs'.
             (λrs.
                  rs 1 + rs 5 = RS 1 ∧ rs 0 = N ∧
                  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 4 = 0 ∧
                  rs 3 + rs 1 * rs 2 = RS 1 * rs 2 ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs' ∧ rs' 1 ≤ N')

Goal proved.
 [....]
⊢ ∃INV.
      (∀rs.
           (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N ⇒
           INV rs) ∧
      (∀rs.
           INV rs ∧ rs 1 = 0 ⇒
           rs 0 = N ∧ rs 5 = RS 1 ∧
           rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
           ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
      ∀N.
          rmcorr exponential 3 (λrs. INV rs⦇1 ↦ rs 1 + 1⦈ ∧ rs 1 = N)
            (SOME 2) (λrs'. INV rs' ∧ rs' 1 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 2
    (λrs.
         (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
    (λrs.
         rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
         rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃Q q2.
            rmcorr exponential 9
              (λrs.
                   rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
                   rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                   rs 3 = rs 5 * rs 2 ∧
                   ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
              (SOME q2) Q ∧
            rmcorr exponential q2 Q (SOME 1)
              (λrs'.
                   (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 11)
          (λrs.
               rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
               rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 5 + rs 1) ∧
               ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) ∧
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
               rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 5 + rs 1) ∧
               ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 1 + rs 5) ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 11)
          (λrs.
               rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 1 + rs 5) ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
                 rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 = rs 5 * rs 2 ∧
                 (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 5 = 0 ⇒
                 rs 0 = N ∧ rs 1 = RS 1 ∧
                 rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 = rs 1 * rs 2 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 10 (λrs. INV rs⦇5 ↦ rs 5 + 1⦈ ∧ rs 5 = N)
                  (SOME 9) (λrs'. INV rs' ∧ rs' 5 ≤ N)
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 1 + rs 5) ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 11)
          (λrs.
               rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
               rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 1 + rs 5) ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 11)
          (λrs.
               rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
               rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 5 + rs 1) ∧
               ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) ∧
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
               rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * (rs 5 + rs 1) ∧
               ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃Q q2.
            rmcorr exponential 9
              (λrs.
                   rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
                   rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                   rs 3 = rs 5 * rs 2 ∧
                   ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
              (SOME q2) Q ∧
            rmcorr exponential q2 Q (SOME 1)
              (λrs'.
                   (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 11)
          (λrs.
               rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * RS 1 ∧ ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) ∧
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 2 * RS 1 ∧ ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
               rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = rs 5 * rs 2 ∧
               ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
          (SOME 11)
          (λrs.
               rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                  rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 = rs 2 * (rs 5 + rs 1) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                  rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 = rs 2 * (rs 5 + rs 1) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs ∧ rs 5 = 0 ⇒
             rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 10
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                        rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 = rs 2 * (rs 5 + rs 1) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k)
                     rs⦇5 ↦ rs 5 + 1⦈ ∧ rs 5 = N') (SOME 9)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                        rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 = rs 2 * (rs 5 + rs 1) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs' ∧
                   rs' 5 ≤ N')
   
   : proof
> > # OK..
4 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 10
          (λrs.
               (rs⦇5 ↦ rs 5 + 1⦈ 0 = N ∧
                rs⦇5 ↦ rs 5 + 1⦈ 1 + rs⦇5 ↦ rs 5 + 1⦈ 5 = RS 1 ∧
                (rs⦇5 ↦ rs 5 + 1⦈ 1 + rs⦇5 ↦ rs 5 + 1⦈ 5) **
                (rs⦇5 ↦ rs 5 + 1⦈ 0 + 1) * rs⦇5 ↦ rs 5 + 1⦈ 2 =
                RS 1 ** RS 0 ∧
                rs⦇5 ↦ rs 5 + 1⦈ 3 =
                (rs⦇5 ↦ rs 5 + 1⦈ 1 + rs⦇5 ↦ rs 5 + 1⦈ 5) *
                rs⦇5 ↦ rs 5 + 1⦈ 2 ∧
                ∀k.
                    k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒
                    rs⦇5 ↦ rs 5 + 1⦈ k = RS k) ∧ rs 5 = N') (SOME 9)
          (λrs'.
               (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 5 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 2 * (rs 1 + rs 5)
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
    9.  k ≠ 0
   10.  k ≠ 2
   11.  k ≠ 3
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 2 * (rs 1 + rs 5)
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = 0
    5.  rs 5 = RS 1
    6.  rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0
    7.  rs 3 = rs 5 * rs 2
    8.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

4 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                  rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 = rs 2 * (rs 5 + rs 1) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                  rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 = rs 2 * (rs 5 + rs 1) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs ∧ rs 5 = 0 ⇒
             rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 10
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                        rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 = rs 2 * (rs 5 + rs 1) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k)
                     rs⦇5 ↦ rs 5 + 1⦈ ∧ rs 5 = N') (SOME 9)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                        rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                        rs 3 = rs 2 * (rs 5 + rs 1) ∧
                        ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs' ∧
                   rs' 5 ≤ N')
   
   : proof
> > # OK..
4 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 10
          (λrs.
               (rs 0 = N ∧ rs 1 + (rs 5 + 1) = RS 1 ∧
                rs 2 * (rs 1 + (rs 5 + 1)) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 = rs 2 * (rs 1 + (rs 5 + 1)) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
               rs 5 = N') (SOME 9)
          (λrs'.
               (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 5 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = RS 1
    5.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
    9.  k ≠ 0
   10.  k ≠ 2
   11.  k ≠ 3
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = RS 1
    5.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = 0
    5.  rs 5 = RS 1
    6.  rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0
    7.  rs 3 = rs 5 * rs 2
    8.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

4 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = 0
    5.  rs 5 = RS 1
    6.  rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0
    7.  rs 3 = rs 5 * rs 2
    8.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
   
   : proof
> > # OK..
metis: r[+0+11]+0+0+0+0+0+0+0+0#

Goal proved.
 [.........] ⊢ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

Goal proved.
 [.........] ⊢ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 10
          (λrs.
               (rs 0 = N ∧ rs 1 + (rs 5 + 1) = RS 1 ∧
                rs 2 * (rs 1 + (rs 5 + 1)) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 = rs 2 * (rs 1 + (rs 5 + 1)) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
               rs 5 = N') (SOME 9)
          (λrs'.
               (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 5 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = RS 1
    5.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
    9.  k ≠ 0
   10.  k ≠ 2
   11.  k ≠ 3
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = RS 1
    5.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

3 subgoals
   : proof
> > # OK..
metis: r[+0+11]+0+0+0+0+0+0+0+0#

Goal proved.
 [.........] ⊢ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 10
          (λrs.
               (rs 0 = N ∧ rs 1 + (rs 5 + 1) = RS 1 ∧
                rs 2 * (rs 1 + (rs 5 + 1)) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 = rs 2 * (rs 1 + (rs 5 + 1)) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
               rs 5 = N') (SOME 9)
          (λrs'.
               (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 5 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = RS 1
    5.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
    9.  k ≠ 0
   10.  k ≠ 2
   11.  k ≠ 3
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 = RS 1
    5.  rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 1 * rs 2
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  rs 5 = 0
    9.  k ≠ 0
   10.  k ≠ 2
   11.  k ≠ 3
   12.  k ≠ 1
   ------------------------------------
        rs k = RS k
   
   : proof
> > # OK..

Goal proved.
 [.............] ⊢ rs k = RS k

Goal proved.
 [............] ⊢ rs k = RS k

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 10
          (λrs.
               (rs 0 = N ∧ rs 1 + (rs 5 + 1) = RS 1 ∧
                rs 2 * (rs 1 + (rs 5 + 1)) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                rs 3 = rs 2 * (rs 1 + (rs 5 + 1)) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
               rs 5 = N') (SOME 9)
          (λrs'.
               (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 5 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 9
          (λrs.
               ((rs⦇1 ↦ rs 1 − 1⦈ 0 = N ∧
                 rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1) = RS 1 ∧
                 (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) **
                 (rs⦇1 ↦ rs 1 − 1⦈ 0 + 1) * rs⦇1 ↦ rs 1 − 1⦈ 2 =
                 RS 1 ** RS 0 ∧
                 rs⦇1 ↦ rs 1 − 1⦈ 3 =
                 (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) *
                 rs⦇1 ↦ rs 1 − 1⦈ 2 ∧
                 ∀k.
                     k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒
                     rs⦇1 ↦ rs 1 − 1⦈ k = RS k) ∧ rs⦇1 ↦ rs 1 − 1⦈ 5 = N') ∧
               0 < rs 1) (SOME 9)
          (λrs'.
               (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
                rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
                rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
                ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
               rs' 5 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∀rs.
            ((rs⦇1 ↦ rs 1 − 1⦈ 0 = N ∧
              rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1) = RS 1 ∧
              (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) **
              (rs⦇1 ↦ rs 1 − 1⦈ 0 + 1) * rs⦇1 ↦ rs 1 − 1⦈ 2 =
              RS 1 ** RS 0 ∧
              rs⦇1 ↦ rs 1 − 1⦈ 3 =
              (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) *
              rs⦇1 ↦ rs 1 − 1⦈ 2 ∧
              ∀k.
                  k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒
                  rs⦇1 ↦ rs 1 − 1⦈ k = RS k) ∧ rs⦇1 ↦ rs 1 − 1⦈ 5 = N') ∧
            0 < rs 1 ⇒
            (rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
             rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 = rs 2 * (rs 1 + rs 5) ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
            rs 5 ≤ N'
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 1 + rs 5 = RS 1
    5.  rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0
    6.  rs 3 = rs 2 * (rs 1 + rs 5)
    7.  ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k
    8.  0 < rs 1
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
   
   : proof
> > # OK..
metis: r[+0+11]+0+0+0+0+0+0+0+0#

Goal proved.
 [.........] ⊢ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0

Goal proved.
 [....]
⊢ ∀rs.
      ((rs⦇1 ↦ rs 1 − 1⦈ 0 = N ∧
        rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1) = RS 1 ∧
        (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) **
        (rs⦇1 ↦ rs 1 − 1⦈ 0 + 1) * rs⦇1 ↦ rs 1 − 1⦈ 2 =
        RS 1 ** RS 0 ∧
        rs⦇1 ↦ rs 1 − 1⦈ 3 =
        (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) * rs⦇1 ↦ rs 1 − 1⦈ 2 ∧
        ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs⦇1 ↦ rs 1 − 1⦈ k = RS k) ∧
       rs⦇1 ↦ rs 1 − 1⦈ 5 = N') ∧ 0 < rs 1 ⇒
      (rs 0 = N ∧ rs 1 + rs 5 = RS 1 ∧
       rs 2 * (rs 1 + rs 5) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
       rs 3 = rs 2 * (rs 1 + rs 5) ∧
       ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧ rs 5 ≤ N'

Goal proved.
 [....]
⊢ rmcorr exponential 9
    (λrs.
         ((rs⦇1 ↦ rs 1 − 1⦈ 0 = N ∧
           rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1) = RS 1 ∧
           (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) **
           (rs⦇1 ↦ rs 1 − 1⦈ 0 + 1) * rs⦇1 ↦ rs 1 − 1⦈ 2 =
           RS 1 ** RS 0 ∧
           rs⦇1 ↦ rs 1 − 1⦈ 3 =
           (rs⦇1 ↦ rs 1 − 1⦈ 1 + (rs⦇1 ↦ rs 1 − 1⦈ 5 + 1)) *
           rs⦇1 ↦ rs 1 − 1⦈ 2 ∧
           ∀k.
               k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒
               rs⦇1 ↦ rs 1 − 1⦈ k = RS k) ∧ rs⦇1 ↦ rs 1 − 1⦈ 5 = N') ∧
         0 < rs 1) (SOME 9)
    (λrs'.
         (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 5 ≤ N')

Goal proved.
 [....]
⊢ rmcorr exponential 10
    (λrs.
         (rs 0 = N ∧ rs 1 + (rs 5 + 1) = RS 1 ∧
          rs 2 * (rs 1 + (rs 5 + 1)) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
          rs 3 = rs 2 * (rs 1 + (rs 5 + 1)) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ∧
         rs 5 = N') (SOME 9)
    (λrs'.
         (rs' 0 = N ∧ rs' 1 + rs' 5 = RS 1 ∧
          rs' 2 * (rs' 1 + rs' 5) ** (rs' 0 + 1) = RS 1 ** RS 0 ∧
          rs' 3 = rs' 2 * (rs' 1 + rs' 5) ∧
          ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs' k = RS k) ∧
         rs' 5 ≤ N')

Goal proved.
 [....]
⊢ (∀rs.
       rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
       rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
       (∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) ⇒
       (λrs.
            rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
            rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 3 = rs 2 * (rs 5 + rs 1) ∧
            ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs) ∧
  (∀rs.
       (λrs.
            rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
            rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
            rs 3 = rs 2 * (rs 5 + rs 1) ∧
            ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs ∧ rs 5 = 0 ⇒
       rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
       rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
  ∀N'.
      rmcorr exponential 10
        (λrs.
             (λrs.
                  rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                  rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 = rs 2 * (rs 5 + rs 1) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs⦇5 ↦ rs 5 + 1⦈ ∧
             rs 5 = N') (SOME 9)
        (λrs'.
             (λrs.
                  rs 0 = N ∧ rs 5 + rs 1 = RS 1 ∧
                  rs 2 * (rs 5 + rs 1) ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                  rs 3 = rs 2 * (rs 5 + rs 1) ∧
                  ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) rs' ∧ rs' 5 ≤ N')

Goal proved.
 [....]
⊢ rmcorr exponential 9
    (λrs.
         rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
         rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) (SOME 11)
    (λrs.
         rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
         rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
          (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃Q q2.
            rmcorr exponential 11
              (λrs.
                   rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                   rs 3 = RS 1 * rs 2 ∧
                   ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) (SOME q2) Q ∧
            rmcorr exponential q2 Q (SOME 1)
              (λrs'.
                   (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
          (SOME 12)
          (λrs.
               rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
               ∀k. k ∉ {0; 3} ⇒ rs k = RS k) ∧
        rmcorr exponential 12
          (λrs.
               rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
               ∀k. k ∉ {0; 3} ⇒ rs k = RS k) (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 12
          (λrs.
               rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
               ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
               rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
          (SOME 12)
          (λrs.
               rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
               ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 = RS 1 * rs 2 ∧
                 (∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 2 = 0 ⇒
                 rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 11 (λrs. INV rs⦇2 ↦ rs 2 + 1⦈ ∧ rs 2 = N)
                  (SOME 11) (λrs'. INV rs' ∧ rs' 2 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 = RS 1 * rs 2 ∧ (∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 3} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 3} ⇒ rs k = RS k) rs ∧ rs 2 = 0 ⇒
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 11
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 3} ⇒ rs k = RS k) rs⦇2 ↦ rs 2 + 1⦈ ∧
                   rs 2 = N') (SOME 11)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 3} ⇒ rs k = RS k) rs' ∧ rs' 2 ≤ N')
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
                 rs 3 = RS 1 * rs 2 ∧
                 (∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 2 = 0 ⇒
                 rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
            ∀N.
                rmcorr exponential 11 (λrs. INV rs⦇2 ↦ rs 2 + 1⦈ ∧ rs 2 = N)
                  (SOME 11) (λrs'. INV rs' ∧ rs' 2 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 = RS 1 * rs 2 ∧ (∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs ∧ rs 2 = 0 ⇒
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
        ∀N'.
            rmcorr exponential 11
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs⦇2 ↦ rs 2 + 1⦈ ∧
                   rs 2 = N') (SOME 11)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs' ∧ rs' 2 ≤ N')
   
   : proof
> > # OK..
3 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               (rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 2 = N')
          (SOME 11)
          (λrs'.
               (rs' 0 = N ∧ rs' 3 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 2 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  rs 2 = 0
    7.  k ≠ 0
    8.  k ≠ 3
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0

3 subgoals
   : proof
> > # OK..
metis: r[+0+9]+0+0+0+0+0+0+0+0+3+1+0+0+4+0+0+7+0
Exception raised at folTools.FOL_SOLVER:
Time exception raised
Exception-
   HOL_ERR
     {message = "Time exception raised", origin_function = "FOL_SOLVER",
      origin_structure = "folTools"} raised
> DB.match[] ``_ * _ ** _ = _ ** _``;
val it = (): unit
> val it = []: data list
> > # OK..
metis: r[+0+9]+0+0+0+0+0+0+0+0+3+1+0+0+4+0+0+7
Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 972
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 972",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 972
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 972",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 972
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 972",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> val it = (): unit
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 * RS 1 ** rs 0

2 subgoals
   : proof
> > # OK..
metis: r[+0+9]+0+0+0+0+0+0+0+0+2+1+0+5+0+0+0+7
Exception raised at folTools.FOL_SOLVER:
Time exception raised
Exception-
   HOL_ERR
     {message = "Time exception raised", origin_function = "FOL_SOLVER",
      origin_structure = "folTools"} raised
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               (rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 2 = N')
          (SOME 11)
          (λrs'.
               (rs' 0 = N ∧ rs' 3 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 2 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  rs 2 = 0
    7.  k ≠ 0
    8.  k ≠ 3
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0

3 subgoals
   : proof
> find"**";
val it = []: data list
> **_def;
poly: : error: ; expected but _ was found
Static Errors
> **;
poly: : error: Value or constructor (**) has not been declared Found near **
Static Errors
> find "exp";
val it =
   [(("arithmetic", "EVEN_EXP"),
     (⊢ ∀m n. 0 < n ∧ EVEN m ⇒ EVEN (m ** n), Thm)),
    (("arithmetic", "EVEN_EXP_IFF"),
     (⊢ ∀n m. EVEN (m ** n) ⇔ 0 < n ∧ EVEN m, Thm)),
    (("arithmetic", "EXP"),
     (⊢ (∀m. m ** 0 = 1) ∧ ∀m n. m ** SUC n = m * m ** n, Def)),
    (("arithmetic", "EXP2_LT"),
     (⊢ ∀m n. n DIV 2 < 2 ** m ⇔ n < 2 ** SUC m, Thm)),
    (("arithmetic", "EXP_1"), (⊢ ∀n. 1 ** n = 1 ∧ n ** 1 = n, Thm)),
    (("arithmetic", "EXP_ADD"),
     (⊢ ∀p q n. n ** (p + q) = n ** p * n ** q, Thm)),
    (("arithmetic", "EXP_ALWAYS_BIG_ENOUGH"),
     (⊢ ∀b. 1 < b ⇒ ∀n. ∃m. n ≤ b ** m, Thm)),
    (("arithmetic", "EXP_BASE_INJECTIVE"),
     (⊢ ∀b. 1 < b ⇒ ∀n m. b ** n = b ** m ⇔ n = m, Thm)),
    (("arithmetic", "EXP_BASE_LE_IFF"),
     (⊢ b ** m ≤ b ** n ⇔
        b = 0 ∧ n = 0 ∨ b = 0 ∧ 0 < m ∨ b = 1 ∨ 1 < b ∧ m ≤ n, Thm)),
    (("arithmetic", "EXP_BASE_LE_MONO"),
     (⊢ ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n, Thm)),
    (("arithmetic", "EXP_BASE_LEQ_MONO_IMP"),
     (⊢ ∀n m b. 0 < b ∧ m ≤ n ⇒ b ** m ≤ b ** n, Thm)),
    (("arithmetic", "EXP_BASE_LEQ_MONO_SUC_IMP"),
     (⊢ m ≤ n ⇒ SUC b ** m ≤ SUC b ** n, Thm)),
    (("arithmetic", "EXP_BASE_LT_MONO"),
     (⊢ ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n, Thm)),
    (("arithmetic", "EXP_BASE_MULT"),
     (⊢ ∀z x y. (x * y) ** z = x ** z * y ** z, Thm)),
    (("arithmetic", "EXP_EQ_0"), (⊢ ∀n m. n ** m = 0 ⇔ n = 0 ∧ 0 < m, Thm)),
    (("arithmetic", "EXP_EQ_1"), (⊢ ∀n m. n ** m = 1 ⇔ n = 1 ∨ m = 0, Thm)),
    (("arithmetic", "EXP_EXP_INJECTIVE"),
     (⊢ ∀b1 b2 x. b1 ** x = b2 ** x ⇔ x = 0 ∨ b1 = b2, Thm)),
    (("arithmetic", "EXP_EXP_LE_MONO"),
     (⊢ ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ n = 0, Thm)),
    (("arithmetic", "EXP_EXP_LT_MONO"),
     (⊢ ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n, Thm)),
    (("arithmetic", "EXP_EXP_MULT"),
     (⊢ ∀z x y. x ** (y * z) = (x ** y) ** z, Thm)),
    (("arithmetic", "EXP_MOD"),
     (⊢ 0 < n ⇒ (x MOD n) ** e MOD n = x ** e MOD n, Thm)),
    (("arithmetic", "EXP_SUB"),
     (⊢ ∀p q n. 0 < n ∧ q ≤ p ⇒ n ** (p − q) = n ** p DIV n ** q, Thm)),
    (("arithmetic", "EXP_SUB_NUMERAL"),
     (⊢ 0 < n ⇒
        n ** NUMERAL (BIT1 x) DIV n = n ** (NUMERAL (BIT1 x) − 1) ∧
        n ** NUMERAL (BIT2 x) DIV n = n ** NUMERAL (BIT1 x), Thm)),
    (("arithmetic", "LESS_EXP_SUC_MONO"),
     (⊢ ∀n m. SUC (SUC m) ** n < SUC (SUC m) ** SUC n, Thm)),
    (("arithmetic", "MODEQ_EXP_CONG"),
     (⊢ MODEQ n x y ⇒ MODEQ n (x ** e) (y ** e), Thm)),
    (("arithmetic", "MULT_EXP_MONO"),
     (⊢ ∀p q n m. n * SUC q ** p = m * SUC q ** p ⇔ n = m, Thm)),
    (("arithmetic", "NOT_EXP_0"), (⊢ ∀m n. SUC n ** m ≠ 0, Thm)),
    (("arithmetic", "ODD_EXP"), (⊢ ∀m n. 0 < n ∧ ODD m ⇒ ODD (m ** n), Thm)),
    (("arithmetic", "ODD_EXP_IFF"),
     (⊢ ∀n m. ODD (m ** n) ⇔ n = 0 ∨ ODD m, Thm)),
    (("arithmetic", "ONE_LT_EXP"), (⊢ ∀x y. 1 < x ** y ⇔ 1 < x ∧ 0 < y, Thm)),
    (("arithmetic", "X_LE_X_EXP"), (⊢ 0 < n ⇒ x ≤ x ** n, Thm)),
    (("arithmetic", "X_LT_EXP_X"), (⊢ 1 < b ⇒ x < b ** x, Thm)),
    (("arithmetic", "X_LT_EXP_X_IFF"), (⊢ x < b ** x ⇔ 1 < b ∨ x = 0, Thm)),
    (("arithmetic", "ZERO_EXP"), (⊢ 0 ** x = if x = 0 then 1 else 0, Thm)),
    (("arithmetic", "ZERO_LESS_EXP"), (⊢ ∀m n. 0 < SUC n ** m, Thm)),
    (("arithmetic", "ZERO_LT_EXP"), (⊢ 0 < x ** y ⇔ 0 < x ∨ y = 0, Thm)),
    (("bool", "COND_EXPAND"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ (¬b ∨ t1) ∧ (b ∨ t2), Thm)),
    (("bool", "COND_EXPAND_IMP"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ (b ⇒ t1) ∧ (¬b ⇒ t2), Thm)),
    (("bool", "COND_EXPAND_OR"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ b ∧ t1 ∨ ¬b ∧ t2, Thm)),
    (("bool", "EQ_EXPAND"), (⊢ ∀t1 t2. (t1 ⇔ t2) ⇔ t1 ∧ t2 ∨ ¬t1 ∧ ¬t2, Thm)),
    (("numeral", "numeral_exp"),
     (⊢ (∀n. n ** ZERO = BIT1 ZERO) ∧
        (∀n m. n ** BIT1 m = n * numeral$iSQR (n ** m)) ∧
        ∀n m. n ** BIT2 m = numeral$iSQR n * numeral$iSQR (n ** m), Thm)),
    (("numeral", "numeral_texp_help"),
     (⊢ numeral$texp_help ZERO acc = BIT2 acc ∧
        numeral$texp_help (BIT1 n) acc =
        numeral$texp_help (PRE (BIT1 n)) (BIT1 acc) ∧
        numeral$texp_help (BIT2 n) acc =
        numeral$texp_help (BIT1 n) (BIT1 acc), Thm)),
    (("numeral", "texp_help0"),
     (⊢ numeral$texp_help n 0 = 2 ** (n + 1), Thm)),
    (("numeral", "texp_help_def"),
     (⊢ (∀acc. numeral$texp_help 0 acc = BIT2 acc) ∧
        ∀n acc.
            numeral$texp_help (SUC n) acc = numeral$texp_help n (BIT1 acc),
      Def)),
    (("numeral", "texp_help_thm"),
     (⊢ ∀n a. numeral$texp_help n a = (a + 1) * 2 ** (n + 1), Thm)),
    (("numeral", "TWO_EXP_THM"),
     (⊢ 2 ** 0 = 1 ∧
        2 ** NUMERAL (BIT1 n) =
        NUMERAL (numeral$texp_help (PRE (BIT1 n)) ZERO) ∧
        2 ** NUMERAL (BIT2 n) = NUMERAL (numeral$texp_help (BIT1 n) ZERO),
      Thm)),
    (("patternMatches", "PMATCH_EQUIV_ROWS_EQUIV_EXPAND"),
     (⊢ PMATCH_EQUIV_ROWS v rows1 rows2 ⇔
        PMATCH_EQUIV_ROWS v rows1 = PMATCH_EQUIV_ROWS v rows2, Thm)),
    (("patternMatches", "PMATCH_EXPAND_PRED_def"),
     (⊢ (∀P v rows_before.
             PMATCH_EXPAND_PRED P v rows_before [] ⇔
             ¬PMATCH_IS_EXHAUSTIVE v (REVERSE rows_before) ⇒ P ARB) ∧
        ∀P v rows_before r rows_after.
            PMATCH_EXPAND_PRED P v rows_before (r::rows_after) ⇔
            (r v ≠ NONE ⇒
             EVERY (λr'. r' v ≠ NONE ⇒ r' v = r v) rows_before ⇒
             P (THE (r v))) ∧
            PMATCH_EXPAND_PRED P v (r::rows_before) rows_after, Def)),
    (("patternMatches", "PMATCH_EXPAND_PRED_THM"),
     (⊢ ∀P v rows. P (PMATCH v rows) ⇔ PMATCH_EXPAND_PRED P v [] rows, Thm)),
    (("patternMatches", "PMATCH_EXPAND_PRED_THM_GEN"),
     (⊢ ∀P v rows_before rows_after.
            PMATCH_EXPAND_PRED P v rows_before rows_after ⇔
            EVERY (λr. PMATCH_ROW_COND_NOT_EX_OR_EQ v r rows_after)
              rows_before ⇒
            P (PMATCH v rows_after), Thm)),
    (("pred_set", "EXPLICIT_ENUMERATE_MONO"),
     (⊢ ∀n s. FUNPOW REST n s ⊆ s, Thm)),
    (("pred_set", "EXPLICIT_ENUMERATE_NOT_EMPTY"),
     (⊢ ∀n s. INFINITE s ⇒ FUNPOW REST n s ≠ ∅, Thm)),
    (("pred_set", "IN_INSERT_EXPAND"),
     (⊢ ∀x y P. x ∈ y INSERT P ⇔ x = y ∨ x ≠ y ∧ x ∈ P, Thm)),
    (("pred_set", "INFINITE_EXPLICIT_ENUMERATE"),
     (⊢ ∀s. INFINITE s ⇒ INJ (λn. CHOICE (FUNPOW REST n s)) 𝕌(:num) s, Thm)),
    (("quantHeuristics", "PAIR_EQ_EXPAND"),
     (⊢ ((x,y) = X ⇔ x = FST X ∧ y = SND X) ∧
        (X = (x,y) ⇔ FST X = x ∧ SND X = y), Thm)),
    (("quantHeuristics", "PAIR_EQ_SIMPLE_EXPAND"),
     (⊢ ((x,y) = (x,y') ⇔ y = y') ∧ ((y,x) = (y',x) ⇔ y = y') ∧
        ((FST X,y) = X ⇔ y = SND X) ∧ ((x,SND X) = X ⇔ x = FST X) ∧
        (X = (FST X,y) ⇔ SND X = y) ∧ (X = (x,SND X) ⇔ FST X = x), Thm)),
    (("registerMachine", "exp_facts"),
     (⊢ exponential.In = [1; 0] ∧ exponential.Out = 2 ∧ exponential.q0 = 14 ∧
        exponential.Q = {1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14} ∧
        exponential.tf 1 = Dec 0 (SOME 2) NONE ∧
        exponential.tf 2 = Dec 1 (SOME 3) (SOME 9) ∧
        exponential.tf 3 = Inc 5 (SOME 4) ∧
        exponential.tf 4 = Dec 2 (SOME 5) (SOME 7) ∧
        exponential.tf 5 = Inc 3 (SOME 6) ∧
        exponential.tf 6 = Inc 4 (SOME 4) ∧
        exponential.tf 7 = Dec 4 (SOME 8) (SOME 2) ∧
        exponential.tf 8 = Inc 2 (SOME 7) ∧
        exponential.tf 9 = Dec 5 (SOME 10) (SOME 11) ∧
        exponential.tf 10 = Inc 1 (SOME 9) ∧
        exponential.tf 11 = Dec 2 (SOME 11) (SOME 12) ∧
        exponential.tf 12 = Dec 3 (SOME 13) (SOME 1) ∧
        exponential.tf 13 = Inc 2 (SOME 12) ∧
        exponential.tf 14 = Inc 2 (SOME 1), Thm)),
    (("registerMachine", "exponential_def"),
     (⊢ exponential =
        <|Q := {1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14};
          tf :=
            (λs.
                 case s of
                   14 => Inc 2 (SOME 1)
                 | 1 => Dec 0 (SOME 2) NONE
                 | 2 => Dec 1 (SOME 3) (SOME 9)
                 | 3 => Inc 5 (SOME 4)
                 | 4 => Dec 2 (SOME 5) (SOME 7)
                 | 5 => Inc 3 (SOME 6)
                 | 6 => Inc 4 (SOME 4)
                 | 7 => Dec 4 (SOME 8) (SOME 2)
                 | 8 => Inc 2 (SOME 7)
                 | 9 => Dec 5 (SOME 10) (SOME 11)
                 | 10 => Inc 1 (SOME 9)
                 | 11 => Dec 2 (SOME 11) (SOME 12)
                 | 12 => Dec 3 (SOME 13) (SOME 1)
                 | 13 => Inc 2 (SOME 12)
                 | v => ARB); q0 := 14; In := [1; 0]; Out := 2|>, Def)),
    (("sum", "cond_sum_expand"),
     (⊢ (∀x y z. (if P then INR x else INL y) = INR z ⇔ P ∧ z = x) ∧
        (∀x y z. (if P then INR x else INL y) = INL z ⇔ ¬P ∧ z = y) ∧
        (∀x y z. (if P then INL x else INR y) = INL z ⇔ P ∧ z = x) ∧
        ∀x y z. (if P then INL x else INR y) = INR z ⇔ ¬P ∧ z = y, Thm))]:
   data list
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..

Exception raised at Absyn.Absyn:
at line 973, character 46:
Don't expect to find a <end of input> in this position after a (
in compiler-generated text and at line 973, character 46.

Exception-
   HOL_ERR
     {message =
      "at line 973, character 46:\nDon't expect to find a <end of input> in this position after a (\nin compiler-generated text and at line 973, character 46.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 973
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 973",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 973
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 973",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 973
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 973",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # poly: : error: Type error in function application.
   Function: e : tactic -> proof
   Argument: () : unit
   Reason:
      Can't unify goal -> goal list * validation to {} (Incompatible types)
Found near e ()
Static Errors
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 973
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 973",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..
metis: r[+0+10]#
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
    8.  RS 1 ** (rs 0 + 1) = RS 1 ** SUC (rs 0)
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
    8.  rs 2 = 0
   ------------------------------------
        RS 1 = 0 ∧ 0 < RS 0

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> find"exp";
val it =
   [(("arithmetic", "EVEN_EXP"),
     (⊢ ∀m n. 0 < n ∧ EVEN m ⇒ EVEN (m ** n), Thm)),
    (("arithmetic", "EVEN_EXP_IFF"),
     (⊢ ∀n m. EVEN (m ** n) ⇔ 0 < n ∧ EVEN m, Thm)),
    (("arithmetic", "EXP"),
     (⊢ (∀m. m ** 0 = 1) ∧ ∀m n. m ** SUC n = m * m ** n, Def)),
    (("arithmetic", "EXP2_LT"),
     (⊢ ∀m n. n DIV 2 < 2 ** m ⇔ n < 2 ** SUC m, Thm)),
    (("arithmetic", "EXP_1"), (⊢ ∀n. 1 ** n = 1 ∧ n ** 1 = n, Thm)),
    (("arithmetic", "EXP_ADD"),
     (⊢ ∀p q n. n ** (p + q) = n ** p * n ** q, Thm)),
    (("arithmetic", "EXP_ALWAYS_BIG_ENOUGH"),
     (⊢ ∀b. 1 < b ⇒ ∀n. ∃m. n ≤ b ** m, Thm)),
    (("arithmetic", "EXP_BASE_INJECTIVE"),
     (⊢ ∀b. 1 < b ⇒ ∀n m. b ** n = b ** m ⇔ n = m, Thm)),
    (("arithmetic", "EXP_BASE_LE_IFF"),
     (⊢ b ** m ≤ b ** n ⇔
        b = 0 ∧ n = 0 ∨ b = 0 ∧ 0 < m ∨ b = 1 ∨ 1 < b ∧ m ≤ n, Thm)),
    (("arithmetic", "EXP_BASE_LE_MONO"),
     (⊢ ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n, Thm)),
    (("arithmetic", "EXP_BASE_LEQ_MONO_IMP"),
     (⊢ ∀n m b. 0 < b ∧ m ≤ n ⇒ b ** m ≤ b ** n, Thm)),
    (("arithmetic", "EXP_BASE_LEQ_MONO_SUC_IMP"),
     (⊢ m ≤ n ⇒ SUC b ** m ≤ SUC b ** n, Thm)),
    (("arithmetic", "EXP_BASE_LT_MONO"),
     (⊢ ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n, Thm)),
    (("arithmetic", "EXP_BASE_MULT"),
     (⊢ ∀z x y. (x * y) ** z = x ** z * y ** z, Thm)),
    (("arithmetic", "EXP_EQ_0"), (⊢ ∀n m. n ** m = 0 ⇔ n = 0 ∧ 0 < m, Thm)),
    (("arithmetic", "EXP_EQ_1"), (⊢ ∀n m. n ** m = 1 ⇔ n = 1 ∨ m = 0, Thm)),
    (("arithmetic", "EXP_EXP_INJECTIVE"),
     (⊢ ∀b1 b2 x. b1 ** x = b2 ** x ⇔ x = 0 ∨ b1 = b2, Thm)),
    (("arithmetic", "EXP_EXP_LE_MONO"),
     (⊢ ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ n = 0, Thm)),
    (("arithmetic", "EXP_EXP_LT_MONO"),
     (⊢ ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n, Thm)),
    (("arithmetic", "EXP_EXP_MULT"),
     (⊢ ∀z x y. x ** (y * z) = (x ** y) ** z, Thm)),
    (("arithmetic", "EXP_MOD"),
     (⊢ 0 < n ⇒ (x MOD n) ** e MOD n = x ** e MOD n, Thm)),
    (("arithmetic", "EXP_SUB"),
     (⊢ ∀p q n. 0 < n ∧ q ≤ p ⇒ n ** (p − q) = n ** p DIV n ** q, Thm)),
    (("arithmetic", "EXP_SUB_NUMERAL"),
     (⊢ 0 < n ⇒
        n ** NUMERAL (BIT1 x) DIV n = n ** (NUMERAL (BIT1 x) − 1) ∧
        n ** NUMERAL (BIT2 x) DIV n = n ** NUMERAL (BIT1 x), Thm)),
    (("arithmetic", "LESS_EXP_SUC_MONO"),
     (⊢ ∀n m. SUC (SUC m) ** n < SUC (SUC m) ** SUC n, Thm)),
    (("arithmetic", "MODEQ_EXP_CONG"),
     (⊢ MODEQ n x y ⇒ MODEQ n (x ** e) (y ** e), Thm)),
    (("arithmetic", "MULT_EXP_MONO"),
     (⊢ ∀p q n m. n * SUC q ** p = m * SUC q ** p ⇔ n = m, Thm)),
    (("arithmetic", "NOT_EXP_0"), (⊢ ∀m n. SUC n ** m ≠ 0, Thm)),
    (("arithmetic", "ODD_EXP"), (⊢ ∀m n. 0 < n ∧ ODD m ⇒ ODD (m ** n), Thm)),
    (("arithmetic", "ODD_EXP_IFF"),
     (⊢ ∀n m. ODD (m ** n) ⇔ n = 0 ∨ ODD m, Thm)),
    (("arithmetic", "ONE_LT_EXP"), (⊢ ∀x y. 1 < x ** y ⇔ 1 < x ∧ 0 < y, Thm)),
    (("arithmetic", "X_LE_X_EXP"), (⊢ 0 < n ⇒ x ≤ x ** n, Thm)),
    (("arithmetic", "X_LT_EXP_X"), (⊢ 1 < b ⇒ x < b ** x, Thm)),
    (("arithmetic", "X_LT_EXP_X_IFF"), (⊢ x < b ** x ⇔ 1 < b ∨ x = 0, Thm)),
    (("arithmetic", "ZERO_EXP"), (⊢ 0 ** x = if x = 0 then 1 else 0, Thm)),
    (("arithmetic", "ZERO_LESS_EXP"), (⊢ ∀m n. 0 < SUC n ** m, Thm)),
    (("arithmetic", "ZERO_LT_EXP"), (⊢ 0 < x ** y ⇔ 0 < x ∨ y = 0, Thm)),
    (("bool", "COND_EXPAND"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ (¬b ∨ t1) ∧ (b ∨ t2), Thm)),
    (("bool", "COND_EXPAND_IMP"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ (b ⇒ t1) ∧ (¬b ⇒ t2), Thm)),
    (("bool", "COND_EXPAND_OR"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ b ∧ t1 ∨ ¬b ∧ t2, Thm)),
    (("bool", "EQ_EXPAND"), (⊢ ∀t1 t2. (t1 ⇔ t2) ⇔ t1 ∧ t2 ∨ ¬t1 ∧ ¬t2, Thm)),
    (("numeral", "numeral_exp"),
     (⊢ (∀n. n ** ZERO = BIT1 ZERO) ∧
        (∀n m. n ** BIT1 m = n * numeral$iSQR (n ** m)) ∧
        ∀n m. n ** BIT2 m = numeral$iSQR n * numeral$iSQR (n ** m), Thm)),
    (("numeral", "numeral_texp_help"),
     (⊢ numeral$texp_help ZERO acc = BIT2 acc ∧
        numeral$texp_help (BIT1 n) acc =
        numeral$texp_help (PRE (BIT1 n)) (BIT1 acc) ∧
        numeral$texp_help (BIT2 n) acc =
        numeral$texp_help (BIT1 n) (BIT1 acc), Thm)),
    (("numeral", "texp_help0"),
     (⊢ numeral$texp_help n 0 = 2 ** (n + 1), Thm)),
    (("numeral", "texp_help_def"),
     (⊢ (∀acc. numeral$texp_help 0 acc = BIT2 acc) ∧
        ∀n acc.
            numeral$texp_help (SUC n) acc = numeral$texp_help n (BIT1 acc),
      Def)),
    (("numeral", "texp_help_thm"),
     (⊢ ∀n a. numeral$texp_help n a = (a + 1) * 2 ** (n + 1), Thm)),
    (("numeral", "TWO_EXP_THM"),
     (⊢ 2 ** 0 = 1 ∧
        2 ** NUMERAL (BIT1 n) =
        NUMERAL (numeral$texp_help (PRE (BIT1 n)) ZERO) ∧
        2 ** NUMERAL (BIT2 n) = NUMERAL (numeral$texp_help (BIT1 n) ZERO),
      Thm)),
    (("patternMatches", "PMATCH_EQUIV_ROWS_EQUIV_EXPAND"),
     (⊢ PMATCH_EQUIV_ROWS v rows1 rows2 ⇔
        PMATCH_EQUIV_ROWS v rows1 = PMATCH_EQUIV_ROWS v rows2, Thm)),
    (("patternMatches", "PMATCH_EXPAND_PRED_def"),
     (⊢ (∀P v rows_before.
             PMATCH_EXPAND_PRED P v rows_before [] ⇔
             ¬PMATCH_IS_EXHAUSTIVE v (REVERSE rows_before) ⇒ P ARB) ∧
        ∀P v rows_before r rows_after.
            PMATCH_EXPAND_PRED P v rows_before (r::rows_after) ⇔
            (r v ≠ NONE ⇒
             EVERY (λr'. r' v ≠ NONE ⇒ r' v = r v) rows_before ⇒
             P (THE (r v))) ∧
            PMATCH_EXPAND_PRED P v (r::rows_before) rows_after, Def)),
    (("patternMatches", "PMATCH_EXPAND_PRED_THM"),
     (⊢ ∀P v rows. P (PMATCH v rows) ⇔ PMATCH_EXPAND_PRED P v [] rows, Thm)),
    (("patternMatches", "PMATCH_EXPAND_PRED_THM_GEN"),
     (⊢ ∀P v rows_before rows_after.
            PMATCH_EXPAND_PRED P v rows_before rows_after ⇔
            EVERY (λr. PMATCH_ROW_COND_NOT_EX_OR_EQ v r rows_after)
              rows_before ⇒
            P (PMATCH v rows_after), Thm)),
    (("pred_set", "EXPLICIT_ENUMERATE_MONO"),
     (⊢ ∀n s. FUNPOW REST n s ⊆ s, Thm)),
    (("pred_set", "EXPLICIT_ENUMERATE_NOT_EMPTY"),
     (⊢ ∀n s. INFINITE s ⇒ FUNPOW REST n s ≠ ∅, Thm)),
    (("pred_set", "IN_INSERT_EXPAND"),
     (⊢ ∀x y P. x ∈ y INSERT P ⇔ x = y ∨ x ≠ y ∧ x ∈ P, Thm)),
    (("pred_set", "INFINITE_EXPLICIT_ENUMERATE"),
     (⊢ ∀s. INFINITE s ⇒ INJ (λn. CHOICE (FUNPOW REST n s)) 𝕌(:num) s, Thm)),
    (("quantHeuristics", "PAIR_EQ_EXPAND"),
     (⊢ ((x,y) = X ⇔ x = FST X ∧ y = SND X) ∧
        (X = (x,y) ⇔ FST X = x ∧ SND X = y), Thm)),
    (("quantHeuristics", "PAIR_EQ_SIMPLE_EXPAND"),
     (⊢ ((x,y) = (x,y') ⇔ y = y') ∧ ((y,x) = (y',x) ⇔ y = y') ∧
        ((FST X,y) = X ⇔ y = SND X) ∧ ((x,SND X) = X ⇔ x = FST X) ∧
        (X = (FST X,y) ⇔ SND X = y) ∧ (X = (x,SND X) ⇔ FST X = x), Thm)),
    (("registerMachine", "exp_facts"),
     (⊢ exponential.In = [1; 0] ∧ exponential.Out = 2 ∧ exponential.q0 = 14 ∧
        exponential.Q = {1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14} ∧
        exponential.tf 1 = Dec 0 (SOME 2) NONE ∧
        exponential.tf 2 = Dec 1 (SOME 3) (SOME 9) ∧
        exponential.tf 3 = Inc 5 (SOME 4) ∧
        exponential.tf 4 = Dec 2 (SOME 5) (SOME 7) ∧
        exponential.tf 5 = Inc 3 (SOME 6) ∧
        exponential.tf 6 = Inc 4 (SOME 4) ∧
        exponential.tf 7 = Dec 4 (SOME 8) (SOME 2) ∧
        exponential.tf 8 = Inc 2 (SOME 7) ∧
        exponential.tf 9 = Dec 5 (SOME 10) (SOME 11) ∧
        exponential.tf 10 = Inc 1 (SOME 9) ∧
        exponential.tf 11 = Dec 2 (SOME 11) (SOME 12) ∧
        exponential.tf 12 = Dec 3 (SOME 13) (SOME 1) ∧
        exponential.tf 13 = Inc 2 (SOME 12) ∧
        exponential.tf 14 = Inc 2 (SOME 1), Thm)),
    (("registerMachine", "exponential_def"),
     (⊢ exponential =
        <|Q := {1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14};
          tf :=
            (λs.
                 case s of
                   14 => Inc 2 (SOME 1)
                 | 1 => Dec 0 (SOME 2) NONE
                 | 2 => Dec 1 (SOME 3) (SOME 9)
                 | 3 => Inc 5 (SOME 4)
                 | 4 => Dec 2 (SOME 5) (SOME 7)
                 | 5 => Inc 3 (SOME 6)
                 | 6 => Inc 4 (SOME 4)
                 | 7 => Dec 4 (SOME 8) (SOME 2)
                 | 8 => Inc 2 (SOME 7)
                 | 9 => Dec 5 (SOME 10) (SOME 11)
                 | 10 => Inc 1 (SOME 9)
                 | 11 => Dec 2 (SOME 11) (SOME 12)
                 | 12 => Dec 3 (SOME 13) (SOME 1)
                 | 13 => Inc 2 (SOME 12)
                 | v => ARB); q0 := 14; In := [1; 0]; Out := 2|>, Def)),
    (("sum", "cond_sum_expand"),
     (⊢ (∀x y z. (if P then INR x else INL y) = INR z ⇔ P ∧ z = x) ∧
        (∀x y z. (if P then INR x else INL y) = INL z ⇔ ¬P ∧ z = y) ∧
        (∀x y z. (if P then INL x else INR y) = INL z ⇔ P ∧ z = x) ∧
        ∀x y z. (if P then INL x else INR y) = INR z ⇔ ¬P ∧ z = y, Thm))]:
   data list
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
    8.  RS 1 ** (rs 0 + 1) = RS 1 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
    8.  rs 2 = 0
   ------------------------------------
        RS 1 = 0 ∧ 0 < RS 0

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
    9.  rs 2 * RS 1 ** SUC (rs 0) = rs 2 * RS 1 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
    8.  RS 1 ** (rs 0 + 1) = RS 1 ** SUC (rs 0)
    9.  rs 2 * RS 1 ** SUC (rs 0) = RS 1 * rs 2 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  T
    8.  rs 2 = 0
    9.  rs 2 * RS 1 ** SUC (rs 0) = RS 1 * rs 2 * RS 1 ** rs 0
   ------------------------------------
        RS 1 = 0 ∧ 0 < RS 0

2 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
    9.  rs 2 * RS 1 ** SUC (rs 0) = rs 2 * RS 1 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> MULT_COMM;
val it = ⊢ ∀m n. m * n = n * m: thm
> > # OK..
Exception- Interrupt raised
> > # OK..
Exception- Interrupt raised
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
    9.  rs 2 * RS 1 ** SUC (rs 0) = rs 2 * RS 1 * RS 1 ** rs 0
   10.  rs 2 * RS 1 * RS 1 ** rs 0 = RS 1 * rs 2 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
    9.  rs 2 * RS 1 ** SUC (rs 0) = rs 2 * RS 1 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0
    5.  rs 3 = RS 1 * rs 2
    6.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    7.  rs 0 + 1 = SUC (rs 0)
    8.  rs 2 * RS 1 ** (rs 0 + 1) = rs 2 * RS 1 ** SUC (rs 0)
    9.  rs 2 * RS 1 ** SUC (rs 0) = rs 2 * RS 1 * RS 1 ** rs 0
   10.  RS 1 * rs 2 * RS 1 ** rs 0 = rs 2 * RS 1 * RS 1 ** rs 0
   ------------------------------------
        RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..
Exception- Interrupt raised
> > # OK..
metis: r[+0+13]#

Goal proved.
 [...........] ⊢ RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0

Goal proved.
 [..........] ⊢ RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0

Goal proved.
 [.........] ⊢ RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0

Goal proved.
 [........] ⊢ RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0

Goal proved.
 [.......] ⊢ RS 1 * rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               (rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 2 = N')
          (SOME 11)
          (λrs'.
               (rs' 0 = N ∧ rs' 3 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 2 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  rs 2 = 0
    7.  k ≠ 0
    8.  k ≠ 3
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..

Goal proved.
 [.........] ⊢ rs k = RS k

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 11
          (λrs.
               (rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 2 = N')
          (SOME 11)
          (λrs'.
               (rs' 0 = N ∧ rs' 3 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 2 ≤ N')
   
   : proof
> > # OK..

Goal proved.
⊢ rmcorr exponential 11
    (λrs.
         (rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 2 = N') (SOME 11)
    (λrs'.
         (rs' 0 = N ∧ rs' 3 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 2 ≤ N')

Goal proved.
 [....]
⊢ (∀rs.
       rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
       rs 3 = RS 1 * rs 2 ∧ (∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
       (λrs.
            rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
            ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs) ∧
  (∀rs.
       (λrs.
            rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
            ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs ∧ rs 2 = 0 ⇒
       rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
       ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
  ∀N'.
      rmcorr exponential 11
        (λrs.
             (λrs.
                  rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs⦇2 ↦ rs 2 + 1⦈ ∧
             rs 2 = N') (SOME 11)
        (λrs'.
             (λrs.
                  rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs' ∧ rs' 2 ≤ N')

Goal proved.
 [....]
⊢ ∃INV.
      (∀rs.
           rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
           rs 3 = RS 1 * rs 2 ∧ (∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
           INV rs) ∧
      (∀rs.
           INV rs ∧ rs 2 = 0 ⇒
           rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
           ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ∧
      ∀N.
          rmcorr exponential 11 (λrs. INV rs⦇2 ↦ rs 2 + 1⦈ ∧ rs 2 = N)
            (SOME 11) (λrs'. INV rs' ∧ rs' 2 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 11
    (λrs.
         rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
         rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
    (SOME 12)
    (λrs.
         rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
         ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k)

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 12
          (λrs.
               rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
               ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) (SOME 1)
          (λrs'.
               (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                 (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 3 = 0 ⇒
                 (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
            ∀N.
                rmcorr exponential 13 (λrs. INV rs⦇3 ↦ rs 3 + 1⦈ ∧ rs 3 = N)
                  (SOME 12) (λrs'. INV rs' ∧ rs' 3 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 3 = 0 ⇒
             (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
        ∀N'.
            rmcorr exponential 13
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇3 ↦ rs 3 + 1⦈ ∧
                   rs 3 = N') (SOME 12)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 3 ≤ N')
   
   : proof
> > # OK..
5 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 13
          (λrs.
               (rs⦇3 ↦ rs 3 + 1⦈ 0 = N ∧
                RS 1 ** rs⦇3 ↦ rs 3 + 1⦈ 0 * rs⦇3 ↦ rs 3 + 1⦈ 2 =
                RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs⦇3 ↦ rs 3 + 1⦈ k = RS k) ∧
               rs 3 = N') (SOME 12)
          (λrs'.
               (rs' 0 = N ∧ rs' 2 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k
    6.  rs 3 = 0
   ------------------------------------
        rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  k ≠ 0
    7.  k ≠ 2
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        0 < RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        RS 1 = 0

5 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 3 = 0 ⇒
             (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
        ∀N'.
            rmcorr exponential 13
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇3 ↦ rs 3 + 1⦈ ∧
                   rs 3 = N') (SOME 12)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 3 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (RS 1 = 0 ∧ 0 < RS 0) ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
        (∀rs.
             (rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 3 = 0 ⇒
             rs 2 * RS 1 ** N = RS 1 ** RS 0) ∧
        ∀N'.
            rmcorr exponential 13
              (λrs.
                   (rs⦇3 ↦ rs 3 + 1⦈ 0 = N ∧
                    RS 1 ** rs⦇3 ↦ rs 3 + 1⦈ 0 * rs⦇3 ↦ rs 3 + 1⦈ 2 =
                    RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs⦇3 ↦ rs 3 + 1⦈ k = RS k) ∧
                   rs 3 = N') (SOME 12)
              (λrs'.
                   (rs' 0 = N ∧ rs' 2 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                    ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 3 = 0 ⇒
             (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
        ∀N'.
            rmcorr exponential 13
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇3 ↦ rs 3 + 1⦈ ∧
                   rs 3 = N') (SOME 12)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 3 ≤ N')
   
   : proof
> > # OK..
4 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 13
          (λrs.
               (rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ (if 3 = k then rs k + 1 else rs k) = RS k) ∧
               rs 3 = N') (SOME 12)
          (λrs'.
               (rs' 0 = N ∧ rs' 2 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  k ≠ 0
    7.  k ≠ 2
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        0 < RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        RS 1 = 0

4 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 3 = 0 ⇒
             (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
        ∀N'.
            rmcorr exponential 13
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇3 ↦ rs 3 + 1⦈ ∧
                   rs 3 = N') (SOME 12)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 3 ≤ N')
   
   : proof
> > # OK..
4 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 13
          (λrs.
               (rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ (if 3 = k then rs k + 1 else rs k) = RS k) ∧
               rs 3 = N') (SOME 12)
          (λrs'.
               (rs' 0 = N ∧ rs' 2 * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  k ≠ 0
    7.  k ≠ 2
   ------------------------------------
        rs k = RS k
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        0 < RS 0
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k
   ------------------------------------
        RS 1 = 0

4 subgoals
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs ∧ rs 3 = 0 ⇒
             (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
        ∀N'.
            rmcorr exponential 13
              (λrs.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇3 ↦ rs 3 + 1⦈ ∧
                   rs 3 = N') (SOME 12)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧ rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 3 ≤ N')
   
   : proof
> # > val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∃INV.
            (∀rs.
                 rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                 (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs 3 = 0 ⇒
                 (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
            ∀N.
                rmcorr exponential 13 (λrs. INV rs⦇3 ↦ rs 3 + 1⦈ ∧ rs 3 = N)
                  (SOME 12) (λrs'. INV rs' ∧ rs' 3 ≤ N)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        (∀rs.
             rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs ∧ rs 3 = 0 ⇒
             (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
        ∀N'.
            rmcorr exponential 13
              (λrs.
                   (λrs.
                        rs 0 = N ∧
                        (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs⦇3 ↦ rs 3 + 1⦈ ∧
                   rs 3 = N') (SOME 12)
              (λrs'.
                   (λrs.
                        rs 0 = N ∧
                        (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                        ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs' ∧ rs' 3 ≤ N')
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 13
          (λrs.
               (rs 0 = N ∧
                (rs 3 + (rs 2 + 1)) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 3 = N')
          (SOME 12)
          (λrs'.
               (rs' 0 = N ∧ (rs' 3 + rs' 2) * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  rs 2 * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  rs 3 = 0
    7.  k ≠ 0
    8.  k ≠ 2
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..

Goal proved.
 [.........] ⊢ rs k = RS k

Remaining subgoals:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 13
          (λrs.
               (rs 0 = N ∧
                (rs 3 + (rs 2 + 1)) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 3 = N')
          (SOME 12)
          (λrs'.
               (rs' 0 = N ∧ (rs' 3 + rs' 2) * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        rmcorr exponential 12
          (λrs.
               ((rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
                 (rs⦇2 ↦ rs 2 − 1⦈ 3 + (rs⦇2 ↦ rs 2 − 1⦈ 2 + 1)) *
                 RS 1 ** rs⦇2 ↦ rs 2 − 1⦈ 0 =
                 RS 1 ** RS 0 ∧
                 ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧
                rs⦇2 ↦ rs 2 − 1⦈ 3 = N') ∧ 0 < rs 2) (SOME 12)
          (λrs'.
               (rs' 0 = N ∧ (rs' 3 + rs' 2) * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
                ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
   ------------------------------------
        ∀rs.
            ((rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
              (rs⦇2 ↦ rs 2 − 1⦈ 3 + (rs⦇2 ↦ rs 2 − 1⦈ 2 + 1)) *
              RS 1 ** rs⦇2 ↦ rs 2 − 1⦈ 0 =
              RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧
             rs⦇2 ↦ rs 2 − 1⦈ 3 = N') ∧ 0 < rs 2 ⇒
            (rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
             ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 3 ≤ N'
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS 2 = 0
    1.  RS 3 = 0
    2.  RS 4 = 0
    3.  RS 5 = 0
    4.  (rs 3 + (rs 2 − 1 + 1)) * RS 1 ** rs 0 = RS 1 ** RS 0
    5.  ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k
    6.  0 < rs 2
   ------------------------------------
        (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0
   
   : proof
> > # OK..

Goal proved.
 [......] ⊢ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0

Goal proved.
 [....]
⊢ ∀rs.
      ((rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
        (rs⦇2 ↦ rs 2 − 1⦈ 3 + (rs⦇2 ↦ rs 2 − 1⦈ 2 + 1)) *
        RS 1 ** rs⦇2 ↦ rs 2 − 1⦈ 0 =
        RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧
       rs⦇2 ↦ rs 2 − 1⦈ 3 = N') ∧ 0 < rs 2 ⇒
      (rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
       ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 3 ≤ N'

Goal proved.
 [....]
⊢ rmcorr exponential 12
    (λrs.
         ((rs⦇2 ↦ rs 2 − 1⦈ 0 = N ∧
           (rs⦇2 ↦ rs 2 − 1⦈ 3 + (rs⦇2 ↦ rs 2 − 1⦈ 2 + 1)) *
           RS 1 ** rs⦇2 ↦ rs 2 − 1⦈ 0 =
           RS 1 ** RS 0 ∧
           ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs⦇2 ↦ rs 2 − 1⦈ k = RS k) ∧
          rs⦇2 ↦ rs 2 − 1⦈ 3 = N') ∧ 0 < rs 2) (SOME 12)
    (λrs'.
         (rs' 0 = N ∧ (rs' 3 + rs' 2) * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')

Goal proved.
 [....]
⊢ rmcorr exponential 13
    (λrs.
         (rs 0 = N ∧ (rs 3 + (rs 2 + 1)) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k) ∧ rs 3 = N') (SOME 12)
    (λrs'.
         (rs' 0 = N ∧ (rs' 3 + rs' 2) * RS 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs' k = RS k) ∧ rs' 3 ≤ N')

Goal proved.
 [....]
⊢ (∀rs.
       rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
       (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
       (λrs.
            rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
            ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs) ∧
  (∀rs.
       (λrs.
            rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
            ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs ∧ rs 3 = 0 ⇒
       (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
       rs 0 ≤ N) ∧
  ∀N'.
      rmcorr exponential 13
        (λrs.
             (λrs.
                  rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs⦇3 ↦ rs 3 + 1⦈ ∧
             rs 3 = N') (SOME 12)
        (λrs'.
             (λrs.
                  rs 0 = N ∧ (rs 3 + rs 2) * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) rs' ∧ rs' 3 ≤ N')

Goal proved.
 [....]
⊢ ∃INV.
      (∀rs.
           rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
           (∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) ⇒
           INV rs) ∧
      (∀rs.
           INV rs ∧ rs 3 = 0 ⇒
           (rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
            ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 ≤ N) ∧
      ∀N.
          rmcorr exponential 13 (λrs. INV rs⦇3 ↦ rs 3 + 1⦈ ∧ rs 3 = N)
            (SOME 12) (λrs'. INV rs' ∧ rs' 3 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 12
    (λrs.
         rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
         ∀k. k ≠ 0 ∧ k ≠ 3 ⇒ rs k = RS k) (SOME 1)
    (λrs'.
         (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 11
    (λrs.
         rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
         rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
    (SOME 12)
    (λrs.
         rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
         ∀k. k ∉ {0; 3} ⇒ rs k = RS k) ∧
  rmcorr exponential 12
    (λrs.
         rs 0 = N ∧ rs 3 * RS 1 ** rs 0 = RS 1 ** RS 0 ∧
         ∀k. k ∉ {0; 3} ⇒ rs k = RS k) (SOME 1)
    (λrs'.
         (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ ∃Q q2.
      rmcorr exponential 11
        (λrs.
             rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
             rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
        (SOME q2) Q ∧
      rmcorr exponential q2 Q (SOME 1)
        (λrs'.
             (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 11
    (λrs.
         rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
         rs 3 = RS 1 * rs 2 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ∧ k ≠ 3 ⇒ rs k = RS k)
    (SOME 1)
    (λrs'.
         (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 9
    (λrs.
         rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
         rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) (SOME 11)
    (λrs.
         rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
         rs 3 = rs 2 * RS 1 ∧ ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) ∧
  rmcorr exponential 11
    (λrs.
         rs 0 = N ∧ rs 2 * RS 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
         rs 3 = rs 2 * RS 1 ∧ ∀k. k ∉ {0; 2; 3} ⇒ rs k = RS k) (SOME 1)
    (λrs'.
         (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ ∃Q q2.
      rmcorr exponential 9
        (λrs.
             rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
             rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
             ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k)
        (SOME q2) Q ∧
      rmcorr exponential q2 Q (SOME 1)
        (λrs'.
             (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 9
    (λrs.
         rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
         rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 5 * rs 2 ∧
         ∀k. k ≠ 0 ∧ k ≠ 1 ∧ k ≠ 2 ∧ k ≠ 3 ∧ k ≠ 5 ⇒ rs k = RS k) (SOME 1)
    (λrs'.
         (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ rmcorr exponential 2
    (λrs.
         (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME 9)
    (λrs.
         rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
         rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 2 * rs 5 ∧
         ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) ∧
  rmcorr exponential 9
    (λrs.
         rs 0 = N ∧ rs 1 = 0 ∧ rs 5 = RS 1 ∧
         rs 2 * rs 5 ** (rs 0 + 1) = RS 1 ** RS 0 ∧ rs 3 = rs 2 * rs 5 ∧
         ∀k. k ∉ {0; 1; 2; 3; 5} ⇒ rs k = RS k) (SOME 1)
    (λrs'.
         (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
          ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ ∃Q q2.
      rmcorr exponential 2
        (λrs.
             (rs 2 * rs 1 ** (rs 0 + 1) = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧ rs 0 = N) (SOME q2) Q ∧
      rmcorr exponential q2 Q (SOME 1)
        (λrs'.
             (rs' 2 * rs' 1 ** rs' 0 = RS 1 ** RS 0 ∧
              ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs' k = RS k) ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ (∀rs.
       rs⦇2 ↦ rs 2 − 1⦈ = RS ∧ 0 < rs 2 ⇒
       (λrs.
            rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧ ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
         rs) ∧
  (∀rs.
       (λrs.
            rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧ ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
         rs ∧ rs 0 = 0 ⇒
       rs 2 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
  ∀N.
      rmcorr exponential 2
        (λrs.
             (λrs.
                  rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs⦇0 ↦ rs 0 + 1⦈ ∧ rs 0 = N)
        (SOME 1)
        (λrs'.
             (λrs.
                  rs 2 * rs 1 ** rs 0 = RS 1 ** RS 0 ∧
                  ∀k. k ∉ {0; 2} ⇒ rs k = RS k) rs' ∧ rs' 0 ≤ N)

Goal proved.
 [....]
⊢ ∃INV.
      (∀rs. rs⦇2 ↦ rs 2 − 1⦈ = RS ∧ 0 < rs 2 ⇒ INV rs) ∧
      (∀rs.
           INV rs ∧ rs 0 = 0 ⇒
           rs 2 = RS 1 ** RS 0 ∧ ∀k. k ≠ 0 ∧ k ≠ 2 ⇒ rs k = RS k) ∧
      ∀N.
          rmcorr exponential 2 (λrs. INV rs⦇0 ↦ rs 0 + 1⦈ ∧ rs 0 = N)
            (SOME 1) (λrs'. INV rs' ∧ rs' 0 ≤ N)
val it =
   Initial goal proved.
   ⊢ ∀RS.
         RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
         rmcorr exponential 14 (λrs. rs = RS) NONE
           (λrs.
                rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧ ∀k. k ∉ {0; 2} ⇒ rs k = RS k):
   proof
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+11]+0+0+0+0+0+0+0+0#
metis: r[+0+11]+0+0+0+0+0+0+0+0#
metis: r[+0+11]+0+0+0+0+0+0+0+0#
metis: r[+0+10]#
metis: r[+0+13]#
val exponential_correct_rmcorr =
   ⊢ ∀RS.
         RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
         rmcorr exponential 14 (λrs. rs = RS) NONE
           (λrs.
                rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧ ∀k. k ∉ {0; 2} ⇒ rs k = RS k):
   thm
> > val it = (): unit
> val it = (): unit
> # # # # # # # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val exp_loop1_1 =
   ⊢ WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential) (rs,SOME 4) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential)
       (rs⦇2 ↦ 0; 3 ↦ rs 3 + rs 2; 4 ↦ rs 4 + rs 2⦈,SOME 7): thm
> > # # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val exp_loop1_2 =
   ⊢ WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential) (rs,SOME 7) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential)
       (rs⦇2 ↦ rs 2 + rs 4; 4 ↦ 0⦈,SOME 2): thm
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val exp_loop1 =
   ⊢ rs 4 = 0 ⇒
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential) (rs,SOME 2) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential)
       (rs⦇1 ↦ 0; 2 ↦ rs 4 + rs 2; 3 ↦ rs 3 + rs 1 * rs 2; 5 ↦ rs 5 + rs 1⦈,
        SOME 9): thm
> > > # # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val exp_loop2 =
   ⊢ WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential) (rs,SOME 9) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential)
       (rs⦇1 ↦ rs 1 + rs 5; 5 ↦ 0⦈,SOME 11): thm
> > # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val exp_loop3 =
   ⊢ WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential) (rs,SOME 11) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential)
       (rs⦇2 ↦ 0⦈,SOME 12): thm
> > # # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val exp_loop4 =
   ⊢ WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential) (rs,SOME 12) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 exponential)
       (rs⦇2 ↦ rs 2 + rs 3; 3 ↦ 0⦈,SOME 1): thm
> > # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
val exp_correct = ⊢ ∀a b. RUN exponential [a; b] = a ** b: thm
> > val it = (): unit
> # # # # # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val mult_loop1 =
   ⊢ WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 multiplication) (rs,SOME 2) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 multiplication)
       (rs⦇1 ↦ 0; 2 ↦ rs 2 + rs 1; 3 ↦ rs 3 + rs 1⦈,SOME 5): thm
> > # # # # # # # # # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
<<HOL message: inventing new type variable names: 'a, 'b>>
val mult_loop2 =
   ⊢ WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 multiplication) (rs,SOME 5) =
     WHILE (λ(rs,so). so ≠ NONE) (run_machine_1 multiplication)
       (rs⦇1 ↦ rs 1 + rs 3; 3 ↦ 0⦈,SOME 1): thm
> > > > # # # # # # # # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
val multi_correct = ⊢ correct2 $* multiplication: thm
> > > > # # # # # # # # val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # poly: : warning: (>>) has infix status but was not preceded by op.
# # # # poly: : warning: (>>) has infix status but was not preceded by op.
# # # # # # # poly: : error: Type error in function application.
   Function: ?? : (tactic -> tactic) * tactic -> tactic
   Argument:
      (... >> ... >> ... ... >> rw [...] >> Induct_on [... ...] >>- 2545, >>)
      :
      (tactic -> tactic) *
      (('a, 'b) gentactic * tactic -> ('a, 'b) gentactic)
   Reason:
      Can't unify term list to 'a -> goal list * (thm list -> 'b)
         (Incompatible types)
Found near
  e
  (
  ... >> ... >> ... ... >> ... ... [...] >>
  map_every qexists_tac [[...], ...] >> rw [])
poly: : error: Type error in function application.
   Function: >> : ('a, 'b) gentactic * tactic -> ('a, 'b) gentactic
   Argument: irule : thm -> tactic
   Reason:
      Can't unify ('a, 'b) gentactic * tactic to thm -> tactic
         (Incompatible types)
Found near
  e
  (
  ... >> ... >> ... ... >> ... ... [...] >>
  map_every qexists_tac [[...], ...] >> rw [])
poly: : error: Type error in function application.
   Function: >> : (goal, thm) gentactic * tactic -> (goal, thm) gentactic
   Argument:
      (
         ... >> ... >> ... ... >>- 2545 ?? >> >> rw [run_step_def],
         >> irule mrInst_correct_V
         ) : (goal, thm) gentactic * (goal list * (thm list -> 'a))
   Reason:
      Can't unify goal -> goal list * validation to
         goal list * (thm list -> 'a) (Incompatible types)
Found near
  e
  (
  ... >> ... >> ... ... >> ... ... [...] >>
  map_every qexists_tac [[...], ...] >> rw [])
Static Errors
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  ∀rs'.
            rs' h = rs (2 ⊗ h) ⇒
            ∃n rs''.
                run_step g (rs',SOME g.q0) n = (rs'',NONE) ∧ rs'' g.Out = N
    4.  ∀rs.
            rs (HD f.In) = N ⇒
            ∃n rs'. run_step f (rs,SOME f.q0) n = (rs',NONE) ∧ rs' f.Out = Op
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  ∀rs'.
            rs' (2 ⊗ h) = rs (2 ⊗ h) ⇒
            ∃n rs''.
                run_step (mrInst 2 g) (rs',SOME g.q0) n = (rs'',NONE) ∧
                rs'' (2 ⊗ g.Out) = N
    8.  rs (0 ⊗ 1) = 0
   ------------------------------------
        ∃n rs'.
            run_step (mrInst 2 g) (rs,SOME g.q0) n = (rs',NONE) ∧
            rs' (0 ⊗ 1) = 0 ∧ rs' (2 ⊗ g.Out) = N
   
   : proof
> > # # # # # # # # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  ∀rs'.
            rs' h = rs (2 ⊗ h) ⇒
            ∃n rs'³'.
                run_step g (rs',SOME g.q0) n = (rs'³',NONE) ∧
                rs'³' g.Out = rs'' (2 ⊗ g.Out)
    4.  ∀rs.
            rs (HD f.In) = rs'' (2 ⊗ g.Out) ⇒
            ∃n rs'. run_step f (rs,SOME f.q0) n = (rs',NONE) ∧ rs' f.Out = Op
    5.  mrInst 2 g with In := [2 ⊗ h] = mrInst 2 g
    6.  g.In = [h]
    7.  ∀rs'.
            rs' (2 ⊗ h) = rs (2 ⊗ h) ⇒
            ∃n rs'³'.
                run_step (mrInst 2 g) (rs',SOME g.q0) n = (rs'³',NONE) ∧
                rs'³' (2 ⊗ g.Out) = rs'' (2 ⊗ g.Out)
    8.  rs (0 ⊗ 1) = 0
    9.  run_step (mrInst 2 g) (rs,SOME g.q0) n = (rs'',NONE) ⇒
        rs'' (0 ⊗ 1) = 0
   ------------------------------------
        run_step (mrInst 2 g) (rs,SOME g.q0) (SUC n) = (rs'',NONE) ⇒
        rs'' (0 ⊗ 1) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  ∀rs'.
            rs' h = rs (2 ⊗ h) ⇒
            ∃n rs'³'.
                run_step g (rs',SOME g.q0) n = (rs'³',NONE) ∧
                rs'³' g.Out = rs'' (2 ⊗ g.Out)
    4.  ∀rs.
            rs (HD f.In) = rs'' (2 ⊗ g.Out) ⇒
            ∃n rs'. run_step f (rs,SOME f.q0) n = (rs',NONE) ∧ rs' f.Out = Op
    5.  mrInst 2 g with In := [2 ⊗ h] = mrInst 2 g
    6.  g.In = [h]
    7.  ∀rs'.
            rs' (2 ⊗ h) = rs (2 ⊗ h) ⇒
            ∃n rs'³'.
                run_step (mrInst 2 g) (rs',SOME g.q0) n = (rs'³',NONE) ∧
                rs'³' (2 ⊗ g.Out) = rs'' (2 ⊗ g.Out)
    8.  rs (0 ⊗ 1) = 0
   ------------------------------------
        run_step (mrInst 2 g) (rs,SOME g.q0) 0 = (rs'',NONE) ⇒
        rs'' (0 ⊗ 1) = 0

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  ∀rs'.
            rs' h = rs (2 ⊗ h) ⇒
            ∃n rs''.
                run_step g (rs',SOME g.q0) n = (rs'',NONE) ∧ rs'' g.Out = N
    4.  ∀rs.
            rs (HD f.In) = N ⇒
            ∃n rs'. run_step f (rs,SOME f.q0) n = (rs',NONE) ∧ rs' f.Out = Op
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  ∀rs'.
            rs' (2 ⊗ h) = rs (2 ⊗ h) ⇒
            ∃n rs''.
                run_step (mrInst 2 g) (rs',SOME g.q0) n = (rs'',NONE) ∧
                rs'' (2 ⊗ g.Out) = N
    8.  rs (0 ⊗ 1) = 0
   ------------------------------------
        ∃n rs'.
            run_step (mrInst 2 g) (rs,SOME g.q0) n = (rs',NONE) ∧
            rs' (0 ⊗ 1) = 0 ∧ rs' (2 ⊗ g.Out) = N
   
   : proof
> > # # # # # # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  ∀rs'.
            rs' h = rs (2 ⊗ h) ⇒
            ∃n rs''.
                run_step g (rs',SOME g.q0) n = (rs'',NONE) ∧ rs'' g.Out = N
    4.  ∀rs.
            rs (HD f.In) = N ⇒
            ∃n rs'. run_step f (rs,SOME f.q0) n = (rs',NONE) ∧ rs' f.Out = Op
    5.  mrInst 2 g with In := [2 ⊗ h] = mrInst 2 g
    6.  g.In = [h]
    7.  ∀rs'.
            rs' (2 ⊗ h) = rs (2 ⊗ h) ⇒
            ∃n rs''.
                run_step (mrInst 2 g) (rs',SOME g.q0) n = (rs'',NONE) ∧
                rs'' (2 ⊗ g.Out) = N
    8.  rs (0 ⊗ 1) = 0
    9.  run_step (mrInst 2 g) (rs,SOME g.q0) n = (rs'',NONE)
   10.  rs'' (2 ⊗ g.Out) = N
   ------------------------------------
        run_step (mrInst 2 g) (rs,SOME g.q0) n = (rs'',NONE) ∧
        rs'' (0 ⊗ 1) = 0 ∧ rs'' (2 ⊗ g.Out) = N
   
   : proof
> # > val it =
   Initial goal:
   
   wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
   rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
   rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
   rmcorr (Cn f g) (Cn f g).q0
     (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
     (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  t = []
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    6.  T
    7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
    8.  g.In = h::t
   ------------------------------------
        rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # # # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  t = []
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    6.  T
    7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
    8.  g.In = h::t
    9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> mrInst_correct_V;
val it =
   ⊢ ∀RS.
         wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs = RS) ∧
         Q' = liftP_V n Q (λrs. ∀k. nfst k ≠ n ⇒ rs k = RS k) ⇒
         rmcorr M q P opt Q ⇒
         rmcorr (mrInst n M) q P' opt Q': thm
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..

Exception raised at Tactic.MATCH_MP_TAC:
No match (THEN1 on line 2489) (THEN1 on line 2490) (THEN1 on line 2493) (THEN1 on line 2502) (THEN1 on line 2505) (THEN1 on line 2520) (THEN1 on line 2521)
Exception-
   HOL_ERR
     {message =
      "No match (THEN1 on line 2489) (THEN1 on line 2490) (THEN1 on line 2493) (THEN1 on line 2502) (THEN1 on line 2505) (THEN1 on line 2520) (THEN1 on line 2521)",
      origin_function = "MATCH_MP_TAC", origin_structure = "Tactic"} raised
> # > val it =
   Initial goal:
   
   wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
   rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
   rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
   rmcorr (Cn f g) (Cn f g).q0
     (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
     (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  t = []
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    6.  T
    7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
    8.  g.In = h::t
    9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> mrInst_correct_V;
val it =
   ⊢ ∀RS.
         wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs = RS) ∧
         Q' = liftP_V n Q (λrs. ∀k. nfst k ≠ n ⇒ rs k = RS k) ⇒
         rmcorr M q P opt Q ⇒
         rmcorr (mrInst n M) q P' opt Q': thm
> liftP_V_def;
val it = ⊢ ∀n P X. liftP_V n P X = (λrs. P (λr. rs (n ⊗ r)) ∧ X rs): thm
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        g.q0 ∈ g.Q

2 subgoals
   : proof
> > # OK..

Goal proved.
 [.] ⊢ g.q0 ∈ g.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
Don't expect to find a <end of input> in this position after a then
in compiler-generated text and on line 2557, characters 64-67.

Exception raised at Absyn.Absyn:
on line 2557, characters 64-67:
Don't expect to find a <end of input> in this position after a then
in compiler-generated text and on line 2557, characters 64-67.

Exception-
   HOL_ERR
     {message =
      "on line 2557, characters 64-67:\nDon't expect to find a <end of input> in this position after a then\nin compiler-generated text and on line 2557, characters 64-67.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M)) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = (λr. if r = 0 ⊗ 1 then 0 else M) k) ∧
        rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = if k = 0 ⊗ 1 then 0 else M)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M))

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M)) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = (λr. if r = 0 ⊗ 1 then 0 else M) k) ∧
        rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. nfst k ≠ 2 ⇒ rs k = if k = 0 ⊗ 1 then 0 else M)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        (λrs. rs (2 ⊗ h) = M ∧ rs = (λr. if r = 0 ⊗ 1 then 0 else M))

2 subgoals
   : proof
> > # OK..
metis: r[+0+19]+0+0+0+0+0+0+0+0+0+0+2+0+0+0+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M)) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = (λr. if r = 0 ⊗ 1 then 0 else M) k) ∧
        rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M)) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = (λr. if r = 0 ⊗ 1 then 0 else M) k) ∧
        rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..

Exception raised at Tactic.MATCH_MP_TAC:
No match
Exception-
   HOL_ERR
     {message = "No match", origin_function = "MATCH_MP_TAC",
      origin_structure = "Tactic"} raised
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = if k = 0 ⊗ 1 then 0 else M)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M))

2 subgoals
   : proof
> > # OK..

Exception raised at Tactic.MATCH_MP_TAC:
No match
Exception-
   HOL_ERR
     {message = "No match", origin_function = "MATCH_MP_TAC",
      origin_structure = "Tactic"} raised
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M)) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = (λr. if r = 0 ⊗ 1 then 0 else M) k) ∧
        rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M)
          (λrs. rs = (λr. if r = 0 ⊗ 1 then 0 else M)) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N)
          (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = (λr. if r = 0 ⊗ 1 then 0 else M) k) ∧
        rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        g.q0 ∈ g.Q

2 subgoals
   : proof
> # > val it =
   Initial goal:
   
   wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
   rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
   rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
   rmcorr (Cn f g) (Cn f g).q0
     (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
     (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs. rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N) NONE
          (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # OK..
3 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0 (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        f.q0 ∈ f.Q
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        NONE = npair_opt 2 NONE

3 subgoals
   : proof
> > # OK..

Goal proved.
⊢ NONE = npair_opt 2 NONE

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0 (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        f.q0 ∈ f.Q

2 subgoals
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#

Goal proved.
 [......] ⊢ f.q0 ∈ f.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0 (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # poly: : error: Type error in function application.
   Function: e : tactic -> proof
   Argument: () : unit
   Reason:
      Can't unify goal -> goal list * validation to {} (Incompatible types)
Found near e ()
Static Errors
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N) = liftP 1 P ∧
            (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧ rmcorr f f.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        f.q0 ∈ f.Q

2 subgoals
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#

Goal proved.
 [......] ⊢ f.q0 ∈ f.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N) = liftP 1 P ∧
            (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧ rmcorr f f.q0 P NONE Q
   
   : proof
> # > val it =
   Initial goal:
   
   wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
   rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
   rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
   rmcorr (Cn f g) (Cn f g).q0
     (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
     (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In))
          (0 ⊗ g.q0)
          (λrs. rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (1 ⊗ 0) (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)

2 subgoals
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In))
          (0 ⊗ g.q0)
          (λrs. rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (1 ⊗ 0) (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        wfrm (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) ∧
        ∃opt q.
            NONE = npair_opt 1 opt ∧ 1 ⊗ 0 = 1 ⊗ q ∧
            q ∈ (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)).Q ∧
            rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) q
              (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) opt
              (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        NONE = npair_opt 1 NONE

2 subgoals
   : proof
> > # OK..

Goal proved.
⊢ NONE = npair_opt 1 NONE

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
   : proof
> # > val it =
   Initial goal:
   
   wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
   rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
   rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
   rmcorr (Cn f g) (Cn f g).q0
     (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
     (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  t = []
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    6.  T
    7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
    8.  g.In = h::t
    9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> rmcorr_weakening;
val it =
   ⊢ (∀s. P s ⇒ P' s) ∧ (∀s. Q' s ⇒ Q s) ∧ rmcorr m q0 P' q Q' ⇒
     rmcorr m q0 P q Q: thm
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        g.q0 ∈ g.Q

2 subgoals
   : proof
> > # OK..

Goal proved.
 [.] ⊢ g.q0 ∈ g.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            (λrs. rs (2 ⊗ h) = M ∧ rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k ≠ 2 ⇒ rs k = RS k)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 (λrs. rs h = M) (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 (λrs. rs g.Out = N) (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P Q RS.
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs = RS) ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. ∀k. nfst k ≠ 2 ⇒ rs k = RS k) ∧
            rmcorr g g.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        g.q0 ∈ g.Q

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  t = []
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    6.  T
    7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
    8.  g.In = h::t
    9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  t = []
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    6.  T
    7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
    8.  g.In = h::t
    9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃P' Q'.
            (∀s. s (2 ⊗ h) = M ∧ s (0 ⊗ 1) = 0 ⇒ P' s) ∧
            (∀s. Q' s ⇒ s (0 ⊗ 1) = 0 ∧ s (2 ⊗ g.Out) = N) ∧
            rmcorr (mrInst 2 g) g.q0 P' NONE Q'
   
   : proof
> rmcorr_weakening;
val it =
   ⊢ (∀s. P s ⇒ P' s) ∧ (∀s. Q' s ⇒ Q s) ∧ rmcorr m q0 P' q Q' ⇒
     rmcorr m q0 P q Q: thm
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  t = []
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    6.  T
    7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
    8.  g.In = h::t
    9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> rmcorr_weakening;
val it =
   ⊢ (∀s. P s ⇒ P' s) ∧ (∀s. Q' s ⇒ Q s) ∧ rmcorr m q0 P' q Q' ⇒
     rmcorr m q0 P q Q: thm
> > # # # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀RS.
            wfrm M ∧ q ∈ M.Q ∧
            P' = liftP_V n P (λrs. ∃k. nfst k ≠ n ∧ rs k = RS k) ∧
            Q' = liftP_V n Q (λrs. rs k = RS k) ⇒
            rmcorr M q P opt Q ⇒
            rmcorr (mrInst n M) q P' opt Q'
   : proofs
> > # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#
metis: metis: metis: metis: r[+0+18]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+3+0+2+1+0+2+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> > # # # # # # # # # # # # OK..
4 subgoals:
val it =
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (mnum ⊗ r))
    4.  nfst k' ≠ mnum
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   11.  nfst k ≠ mnum
   ------------------------------------
        rsm k = RS k
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (nfst k ⊗ r))
    4.  nfst k' ≠ nfst k
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (nfst k ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (nfst k ⊗ r)) (nfst k)
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = nfst k then rs' (nsnd r) else rsm r)
          rsm rs' (nfst k)
   ------------------------------------
        rs' (nsnd k) = RS k
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (mnum ⊗ r))
    4.  nfst k' ≠ mnum
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   ------------------------------------
        Q (λr. rs' r)
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (mnum ⊗ r))
    4.  nfst k' ≠ mnum
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   ------------------------------------
        run_step (mrInst mnum M) (rsm,SOME q) n =
        ((λr. if nfst r = mnum then rs' (nsnd r) else rsm r),opt)

4 subgoals
   : proof
> > # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#

Goal proved.
 [...........]
⊢ run_step (mrInst mnum M) (rsm,SOME q) n =
  ((λr. if nfst r = mnum then rs' (nsnd r) else rsm r),opt)

Remaining subgoals:
val it =
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (mnum ⊗ r))
    4.  nfst k' ≠ mnum
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   11.  nfst k ≠ mnum
   ------------------------------------
        rsm k = RS k
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (nfst k ⊗ r))
    4.  nfst k' ≠ nfst k
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (nfst k ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (nfst k ⊗ r)) (nfst k)
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = nfst k then rs' (nsnd r) else rsm r)
          rsm rs' (nfst k)
   ------------------------------------
        rs' (nsnd k) = RS k
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (mnum ⊗ r))
    4.  nfst k' ≠ mnum
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   ------------------------------------
        Q (λr. rs' r)

3 subgoals
   : proof
> > # OK..
metis: r[+0+6]#

Goal proved.
 [...........] ⊢ Q (λr. rs' r)

Remaining subgoals:
val it =
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (mnum ⊗ r))
    4.  nfst k' ≠ mnum
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   11.  nfst k ≠ mnum
   ------------------------------------
        rsm k = RS k
   
    0.  wfrm M
    1.  q ∈ M.Q
    2.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    3.  P (λr. rsm (nfst k ⊗ r))
    4.  nfst k' ≠ nfst k
    5.  rsm k' = RS k'
    6.  run_step M ((λr. rsm (nfst k ⊗ r)),SOME q) n = (rs',opt)
    7.  Q rs'
    8.  rs_mrInst_B4 rsm (λr. rsm (nfst k ⊗ r)) (nfst k)
    9.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
   10.  rs_mrInst_Aft (λr. if nfst r = nfst k then rs' (nsnd r) else rsm r)
          rsm rs' (nfst k)
   ------------------------------------
        rs' (nsnd k) = RS k

2 subgoals
   : proof
> > # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+1+1+4+3+2+1+0+2+0+0+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   : proofs
> > # # # # <<HOL warning: parse_term.parse_term: on line 1962, characters 31-33 :
Can't do this sort of reduction>>
Exception-
   HOL_ERR
     {message =
      "on line 1962, characters 31-33:\nCan't do this sort of reduction",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> > # # # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀RS.
            ∃k.
                wfrm M ∧ q ∈ M.Q ∧
                P' = liftP_V n P (λrs. nfst k ≠ n ∧ rs k = RS k) ∧
                Q' = liftP_V n Q (λrs. rs k = RS k) ⇒
                rmcorr M q P opt Q ⇒
                rmcorr (mrInst n M) q P' opt Q'
   : proofs
> > # # # # # # # # # # # # # # # OK..

Exception raised at Tactical.FIRST_ASSUM:
 (THEN1 on line 1980)
Exception-
   HOL_ERR
     {message = " (THEN1 on line 1980)", origin_function = "FIRST_ASSUM",
      origin_structure = "Tactical"} raised
> > # # # # # # # # # # # # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   : proofs
> > # # # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   1. Incomplete goalstack:
        Initial goal:
        ∃k N.
            wfrm M ∧ q ∈ M.Q ∧
            P' = liftP_V n P (λrs. nfst k ≠ n ∧ rs k = N) ∧
            Q' = liftP_V n Q (λrs. rs k = N) ⇒
            rmcorr M q P opt Q ⇒
            rmcorr (mrInst n M) q P' opt Q'
   : proofs
> > # # # # # # # # # # # # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> rmcorr_def;
val it =
   ⊢ ∀M q P qf Q.
         rmcorr M q P qf Q ⇔
         ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',qf) ∧ Q rs': thm
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   : proofs
> > # # # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   1. Incomplete goalstack:
        Initial goal:
        ∃k.
            nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧
            P' = liftP_V n P (λrs. rs k = N) ∧
            Q' = liftP_V n Q (λrs. rs k = N) ⇒
            rmcorr M q P opt Q ⇒
            rmcorr (mrInst n M) q P' opt Q'
   : proofs
> > # # # # # # # # # # # # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> > # OK..
1 subgoal:
val it =
   
   ∃k.
       nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧
       P' = (λrs. P (λr. rs (n ⊗ r)) ∧ rs k = N) ∧
       Q' = (λrs. Q (λr. rs (n ⊗ r)) ∧ rs k = N) ⇒
       (∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs') ⇒
       ∀rs.
           P (λr. rs (n ⊗ r)) ∧ rs k = N ⇒
           ∃n' rs'.
               run_step (mrInst n M) (rs,SOME q) n' = (rs',opt) ∧
               Q (λr. rs' (n ⊗ r)) ∧ rs' k = N
   
   : proof
> > # # # # # # # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> > # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> # > val it =
   Initial goal:
   
   ∃k.
       nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
       Q' = liftP_V n Q (λrs. rs k = N) ⇒
       rmcorr M q P opt Q ⇒
       rmcorr (mrInst n M) q P' opt Q': proof
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   : proofs
> > # # # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   1. Incomplete goalstack:
        Initial goal:
        nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
        Q' = liftP_V n Q (λrs. rs k = N) ⇒
        rmcorr M q P opt Q ⇒
        rmcorr (mrInst n M) q P' opt Q'
   : proofs
> > # # # # # # # # # # # # OK..
2 subgoals:
val it =
   
    0.  nfst k ≠ mnum
    1.  wfrm M
    2.  q ∈ M.Q
    3.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    4.  P (λr. rsm (mnum ⊗ r))
    5.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    6.  Q rs'
    7.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    8.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
    9.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   ------------------------------------
        Q (λr. rs' r)
   
    0.  nfst k ≠ mnum
    1.  wfrm M
    2.  q ∈ M.Q
    3.  ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',opt) ∧ Q rs'
    4.  P (λr. rsm (mnum ⊗ r))
    5.  run_step M ((λr. rsm (mnum ⊗ r)),SOME q) n = (rs',opt)
    6.  Q rs'
    7.  rs_mrInst_B4 rsm (λr. rsm (mnum ⊗ r)) mnum
    8.  ∀opt q n rs rs' mnum rsm rsm'.
            (q ∈ M.Q ∧ rs_mrInst_B4 rsm rs mnum ∧
             rs_mrInst_Aft rsm' rsm rs' mnum) ∧
            run_step M (rs,SOME q) n = (rs',opt) ⇒
            run_step (mrInst mnum M) (rsm,SOME q) n = (rsm',opt)
    9.  rs_mrInst_Aft (λr. if nfst r = mnum then rs' (nsnd r) else rsm r) rsm
          rs' mnum
   ------------------------------------
        run_step (mrInst mnum M) (rsm,SOME q) n =
        ((λr. if nfst r = mnum then rs' (nsnd r) else rsm r),opt)

2 subgoals
   : proof
> # > val it =
   Initial goal:
   
   nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
   Q' = liftP_V n Q (λrs. rs k = N) ⇒
   rmcorr M q P opt Q ⇒
   rmcorr (mrInst n M) q P' opt Q': proof
> > # # # # # # # # # # # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#
metis: metis: r[+0+5]#
val it =
   Initial goal proved.
   ⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
     Q' = liftP_V n Q (λrs. rs k = N) ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': proof
> # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#
metis: metis: r[+0+5]#
val mrInst_correct_V =
   ⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
     Q' = liftP_V n Q (λrs. rs k = N) ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': thm
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Incomplete goalstack:
        Initial goal:
        wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
        rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
          (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  t = []
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
         6.  T
         7.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) t = mrInst 2 g
         8.  g.In = h::t
         9.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
               (λrs. rs (2 ⊗ g.Out) = N)
        ------------------------------------
             rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0)
               NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   : proofs
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃N' P Q k.
            nfst k ≠ 2 ∧
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs k = N') ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. rs k = N') ∧ rmcorr g g.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        g.q0 ∈ g.Q

2 subgoals
   : proof
> > # OK..

Goal proved.
 [.] ⊢ g.q0 ∈ g.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        ∃N' P Q k.
            nfst k ≠ 2 ∧
            (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
            liftP_V 2 P (λrs. rs k = N') ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. rs k = N') ∧ rmcorr g g.q0 P NONE Q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        nfst (0 ⊗ 1) ≠ 2 ∧
        (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
        liftP_V 2 (λrs. rs h = M) (λrs. rs (0 ⊗ 1) = 0) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N) (λrs. rs (0 ⊗ 1) = 0) ∧
        rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH f.In = 1
    3.  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
    5.  mrInst 2 g with In := 2 ⊗ h::MAP (λr. 2 ⊗ r) [] = mrInst 2 g
    6.  g.In = [h]
    7.  rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M) NONE
          (λrs. rs (2 ⊗ g.Out) = N)
   ------------------------------------
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        (λrs. rs (2 ⊗ g.Out) = N ∧ rs (0 ⊗ 1) = 0)
   
   : proof
> > # OK..
metis: r[+0+16]#

Goal proved.
 [........]
⊢ (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
  (λrs. rs (2 ⊗ g.Out) = N ∧ rs (0 ⊗ 1) = 0)

Goal proved.
 [........]
⊢ nfst (0 ⊗ 1) ≠ 2 ∧
  (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) =
  liftP_V 2 (λrs. rs h = M) (λrs. rs (0 ⊗ 1) = 0) ∧
  (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
  liftP_V 2 (λrs. rs g.Out = N) (λrs. rs (0 ⊗ 1) = 0) ∧
  rmcorr g g.q0 (λrs. rs h = M) NONE (λrs. rs g.Out = N)

Goal proved.
 [........]
⊢ ∃N' P Q k.
      nfst k ≠ 2 ∧
      (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) = liftP_V 2 P (λrs. rs k = N') ∧
      (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
      liftP_V 2 Q (λrs. rs k = N') ∧ rmcorr g g.q0 P NONE Q

Goal proved.
 [..........]
⊢ rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ h) = M ∧ rs (0 ⊗ 1) = 0) NONE
    (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
val it =
   Initial goal proved.
   ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
     rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
     rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
     rmcorr (Cn f g) (Cn f g).q0
       (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
       (λrs. rs (Cn f g).Out = Op): proof
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
metis: r[+0+15]#
val Cn_correct =
   ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
     rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
     rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
     rmcorr (Cn f g) (Cn f g).q0
       (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
       (λrs. rs (Cn f g).Out = Op): thm
> # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#
metis: metis: r[+0+5]#
val mrInst_correct_kN =
   ⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
     Q' = liftP_V n Q (λrs. rs k = N) ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': thm
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
metis: r[+0+15]#
val Cn_correct =
   ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
     rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
     rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
     rmcorr (Cn f g) (Cn f g).q0
       (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
       (λrs. rs (Cn f g).Out = Op): thm
> correct_defl
# ;
poly: : error: Value or constructor (correct_defl) has not been declared
Found near correct_defl
Static Errors
> correct_def;
val it = ⊢ ∀m f a. correct m f a ⇔ ∀l. LENGTH l = a ⇒ RUN m l = f l: thm
> correct2_def;
val it = ⊢ ∀f m. correct2 f m ⇔ ∀a b. RUN m [a; b] = f a b: thm
> correct1_def;
val it = ⊢ ∀f m. correct1 f m ⇔ ∀a. RUN m [a] = f a: thm
> find"fml"l;
poly: : error: Value or constructor (l) has not been declared Found near find "fml" l
poly: : error: Type error in function application.
   Function: find "fml" : data list
   Argument: l : bad
   Reason: Value being applied does not have a function type
Found near find "fml" l
Static Errors
> find"fml";
val it = []: data list
> rmcorr-
# ;
poly: : error: <identifier> expected but ; was found
# ;
Static Errors
> rmcorr_def;
val it =
   ⊢ ∀M q P qf Q.
         rmcorr M q P qf Q ⇔
         ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',qf) ∧ Q rs': thm
> # # # Definition has been stored under "correct1_rmcorr_def"
val correct1_rmcorr_def =
   ⊢ ∀f M.
         correct1_rmcorr f M ⇔
         ∀inp. rmcorr M M.q0 (λrs. HD M.In = inp) NONE (λrs. M.Out = f inp):
   thm
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
metis: r[+0+15]#
val Cn_rmcorr =
   ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
     rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
     rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
     rmcorr (Cn f g) (Cn f g).q0
       (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
       (λrs. rs (Cn f g).Out = Op): thm
> correct1_rmcorr
# ;
poly: : error: Value or constructor (correct1_rmcorr) has not been declared
Found near correct1_rmcorr
Static Errors
> correct1_rmcorr;
poly: : error: Value or constructor (correct1_rmcorr) has not been declared
Found near correct1_rmcorr
Static Errors
> correct1_rmcorr_def;
val it =
   ⊢ ∀f M.
         correct1_rmcorr f M ⇔
         ∀inp. rmcorr M M.q0 (λrs. HD M.In = inp) NONE (λrs. M.Out = f inp):
   thm
> Cn_def'
# ;
poly: : error: Value or constructor (Cn_def') has not been declared Found near Cn_def'
Static Errors
> Cn_def;
val it =
   ⊢ ∀f g.
         Cn f g =
         (let
            f' = mrInst 1 f ;
            g' = mrInst 2 g ;
            d1 = dup g'.Out (HD f'.In) (0 ⊗ 1) ;
            mix = [g'; d1; f'] ;
            mix' = MAPi msInst mix
          in
            link_all mix' with In := g'.In): thm
> # # # # # # # # # # # 
Type inference failure: unable to infer a type for the application of

mrInst (1 :num)

on line 1376, characters 15-24

which has type

:rm -> rm

to

F :bool

at line 1376, character 24

unification failure message: Attempt to unify different type operators: registerMachine$rm and min$bool

Exception raised at TotalDefn.xDefine:
at Defn.Hol_defn:
between line 1375, character 2 and line 1382, character 37:
at Defn.parse_quote:
at Preterm.type-analysis:
at line 1376, character 24:

Type inference failure: unable to infer a type for the application of

mrInst (1 :num)

on line 1376, characters 15-24

which has type

:rm -> rm

to

F :bool

at line 1376, character 24

unification failure message: Attempt to unify different type operators: registerMachine$rm and min$bool

Exception-
   HOL_ERR
     {message =
      "at Defn.Hol_defn:\nbetween line 1375, character 2 and line 1382, character 37:\nat Defn.parse_quote:\nat Preterm.type-analysis:\nat line 1376, character 24:\n\nType inference failure: unable to infer a type for the application of\n\nmrInst (1 :num)\n\non line 1376, characters 15-24\n\nwhich has type\n\n:rm -> rm\n\nto\n\nF :bool\n\nat line 1376, character 24\n\nunification failure message: Attempt to unify different type operators: registerMachine$rm and min$bool\n",
      origin_function = "xDefine", origin_structure = "TotalDefn"} raised
> > # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   1. Incomplete goalstack:
        Initial goal:
        wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
        correct1_rmcorr f M1 ∧ correct1_rmcorr g M2 ⇒
        correct1_rmcorr (f ∘ g) (Cn M1 M2)
   : proofs
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0 (λrs. HD M1.In = inp) NONE (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. HD M2.In = inp) NONE (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0 (λrs. HD (Cn M1 M2).In = inp) NONE
          (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0 (λrs. HD M1.In = inp) NONE (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. HD M2.In = inp) NONE (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0 (λrs. HD (Cn M1 M2).In = inp) NONE
          (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
metis: r[+0+15]#
val Cn_rmcorr =
   ⊢ ∀M N Op f g.
         wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
         rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
         rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
         rmcorr (Cn f g) (Cn f g).q0
           (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
           (λrs. rs (Cn f g).Out = Op): thm
> > # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr f M1 ∧ correct1_rmcorr g M2 ⇒
            correct1_rmcorr (f ∘ g) (Cn M1 M2)
   : proofs
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0 (λrs. HD M1.In = inp) NONE (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. HD M2.In = inp) NONE (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0 (λrs. HD (Cn M1 M2).In = inp) NONE
          (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0 (λrs. HD M1.In = inp) NONE (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. HD M2.In = inp) NONE (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0 (λrs. HD (Cn M1 M2).In = inp) NONE
          (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> # > val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0 (λrs. HD M1.In = inp) NONE (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. HD M2.In = inp) NONE (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0 (λrs. HD (Cn M1 M2).In = inp) NONE
          (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> > # OK..

Exception raised at Tactic.MATCH_MP_TAC:
No match
Exception-
   HOL_ERR
     {message = "No match", origin_function = "MATCH_MP_TAC",
      origin_structure = "Tactic"} raised
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0 (λrs. HD M1.In = inp) NONE (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. HD M2.In = inp) NONE (λrs. M2.Out = g inp)
   ------------------------------------
        (∀M N Op f.
             wfrm f ∧ LENGTH M2.In = 1 ∧ LENGTH f.In = 1 ∧
             rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
               (λrs. rs M2.Out = N) ∧
             rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
             rmcorr (Cn f M2) (Cn f M2).q0
               (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
               (λrs. rs (Cn f M2).Out = Op)) ⇒
        rmcorr (Cn M1 M2) (Cn M1 M2).q0 (λrs. HD (Cn M1 M2).In = inp) NONE
          (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0 (λrs. HD M1.In = inp) NONE (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. HD M2.In = inp) NONE (λrs. M2.Out = g inp)
    6.  ∀M N Op f.
            wfrm f ∧ LENGTH f.In = 1 ∧
            rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
              (λrs. rs M2.Out = N) ∧
            rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f M2) (Cn f M2).q0
              (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
              (λrs. rs (Cn f M2).Out = Op)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0 (λrs. HD (Cn M1 M2).In = inp) NONE
          (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> rmcorr_def;
val it =
   ⊢ ∀M q P qf Q.
         rmcorr M q P qf Q ⇔
         ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',qf) ∧ Q rs': thm
> correct1_rmcorr_def;
val it =
   ⊢ ∀f M.
         correct1_rmcorr f M ⇔
         ∀inp. rmcorr M M.q0 (λrs. HD M.In = inp) NONE (λrs. M.Out = f inp):
   thm
> # # # Definition has been stored under "correct1_rmcorr_V_def"
val correct1_rmcorr_V_def =
   ⊢ ∀f M.
         correct1_rmcorr_V f M ⇔
         ∀inp.
             rmcorr M M.q0 (λrs. HD M.In = inp ∧ ∀k. k ≠ HD M.In ⇒ rs k = 0)
               NONE (λrs. M.Out = f inp): thm
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
   : proofs
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0
              (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
              (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0
              (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
              (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0
          (λrs. HD (Cn M1 M2).In = inp ∧ ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0)
          NONE (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> > # OK..
metis: r[+0+12]+0+0+0+0+0+0+0+0+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0
              (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
              (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0
              (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
              (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0
          (λrs. HD (Cn M1 M2).In = inp ∧ ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0)
          NONE (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> # > val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0
              (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
              (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0
              (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
              (λrs. M2.Out = g inp)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0
          (λrs. HD (Cn M1 M2).In = inp ∧ ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0)
          NONE (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0
              (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
              (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0
              (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
              (λrs. M2.Out = g inp)
   ------------------------------------
        (∀M N Op f.
             wfrm f ∧ LENGTH M2.In = 1 ∧ LENGTH f.In = 1 ∧
             rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
               (λrs. rs M2.Out = N) ∧
             rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
             rmcorr (Cn f M2) (Cn f M2).q0
               (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
               (λrs. rs (Cn f M2).Out = Op)) ⇒
        rmcorr (Cn M1 M2) (Cn M1 M2).q0
          (λrs. HD (Cn M1 M2).In = inp ∧ ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0)
          NONE (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm M1
    1.  wfrm M2
    2.  LENGTH M1.In = 1
    3.  LENGTH M2.In = 1
    4.  ∀inp.
            rmcorr M1 M1.q0
              (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
              (λrs. M1.Out = f inp)
    5.  ∀inp.
            rmcorr M2 M2.q0
              (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
              (λrs. M2.Out = g inp)
    6.  ∀M N Op f.
            wfrm f ∧ LENGTH f.In = 1 ∧
            rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
              (λrs. rs M2.Out = N) ∧
            rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f M2) (Cn f M2).q0
              (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
              (λrs. rs (Cn f M2).Out = Op)
   ------------------------------------
        rmcorr (Cn M1 M2) (Cn M1 M2).q0
          (λrs. HD (Cn M1 M2).In = inp ∧ ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0)
          NONE (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> rmcorr_def;
val it =
   ⊢ ∀M q P qf Q.
         rmcorr M q P qf Q ⇔
         ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',qf) ∧ Q rs': thm
> rmcorr_weakening;
val it =
   ⊢ (∀s. P s ⇒ P' s) ∧ (∀s. Q' s ⇒ Q s) ∧ rmcorr m q0 P' q Q' ⇒
     rmcorr m q0 P q Q: thm
> mrInst_correct;
val it =
   ⊢ wfrm M ∧ q ∈ M.Q ∧ P' = liftP n P ∧ Q' = liftP n Q ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': thm
> mrInst_correct_V;
val it =
   ⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
     Q' = liftP_V n Q (λrs. rs k = N) ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': thm
>  correct1_rmcorr_V;
poly: : error: Value or constructor (correct1_rmcorr_V) has not been declared
Found near correct1_rmcorr_V
Static Errors
>  correct1_rmcorr_V_def;;
val it =
   ⊢ ∀f M.
         correct1_rmcorr_V f M ⇔
         ∀inp.
             rmcorr M M.q0 (λrs. HD M.In = inp ∧ ∀k. k ≠ HD M.In ⇒ rs k = 0)
               NONE (λrs. M.Out = f inp): thm
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
Proof of 

∀M N Op f g.
    wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
    rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
      (λrs. rs g.Out = N) ∧
    rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
      (λrs. rs f.Out = Op) ⇒
    rmcorr (Cn f g) (Cn f g).q0
      (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
      (λrs. rs (Cn f g).Out = Op)

failed.
Failed to prove theorem Cn_rmcorr_V.

Exception raised at Tactical.THEN1:
first subgoal not solved by second tactic (THEN1 on line 2648) (THEN1 on line 2657) (THEN1 on line 2660) (THEN1 on line 2675) (THEN1 on line 2676) (THEN1 on line 2683)
Exception-
   HOL_ERR
     {message =
      "first subgoal not solved by second tactic (THEN1 on line 2648) (THEN1 on line 2657) (THEN1 on line 2660) (THEN1 on line 2675) (THEN1 on line 2676) (THEN1 on line 2683)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> > mrInst_correct'
# ;
poly: : error: Value or constructor (mrInst_correct') has not been declared
Found near mrInst_correct'
Static Errors
> ;
> mrInst_correct_V;
val it =
   ⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
     Q' = liftP_V n Q (λrs. rs k = N) ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': thm
> > # # # # # # # # # val it =
   Proof manager status: 4 proofs.
   4. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   3. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#

Exception raised at Tactical.THEN1:
first subgoal not solved by second tactic (THEN1 on line 2648) (THEN1 on line 2657) (THEN1 on line 2660) (THEN1 on line 2675) (THEN1 on line 2676)
Exception-
   HOL_ERR
     {message =
      "first subgoal not solved by second tactic (THEN1 on line 2648) (THEN1 on line 2657) (THEN1 on line 2660) (THEN1 on line 2675) (THEN1 on line 2676)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N) NONE
          (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        rmcorr f f.q0 (λrs. rs h = N) NONE (λrs. rs f.Out = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
       rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
         NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
         NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
              (0 ⊗ g.q0)
              (λrs.
                   rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
                   ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (msInst 2 (mrInst 1 f)).In) = N ∧
               ∀k. k ≠ HD (msInst 2 (mrInst 1 f)).In ∧ nfst k = 1 ⇒ rs k = 0) ∧
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (msInst 2 (mrInst 1 f)).In) = N ∧
               ∀k. k ≠ HD (msInst 2 (mrInst 1 f)).In ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> find"mrInst_correct";
val it =
   [(("registerMachine", "mrInst_correct"),
     (⊢ wfrm M ∧ q ∈ M.Q ∧ P' = liftP n P ∧ Q' = liftP n Q ⇒
        rmcorr M q P opt Q ⇒
        rmcorr (mrInst n M) q P' opt Q', Thm)),
    (("registerMachine", "mrInst_correct_kN"),
     (⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
        Q' = liftP_V n Q (λrs. rs k = N) ⇒
        rmcorr M q P opt Q ⇒
        rmcorr (mrInst n M) q P' opt Q', Thm)),
    (("registerMachine", "mrInst_correct_V"),
     (⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
        Q' = liftP_V n Q (λrs. rs k = N) ⇒
        rmcorr M q P opt Q ⇒
        rmcorr (mrInst n M) q P' opt Q', Thm))]: data list
> # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+1+4+2#
metis: metis: r[+0+5]#
val mrInst_correct_V =
   ⊢ ∀RS.
         wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs = RS) ∧
         Q' = liftP_V n Q (λrs. ∀k. nfst k ≠ n ⇒ rs k = RS k) ⇒
         rmcorr M q P opt Q ⇒
         rmcorr (mrInst n M) q P' opt Q': thm
> find"mrInst_correct";
val it =
   [(("registerMachine", "mrInst_correct"),
     (⊢ wfrm M ∧ q ∈ M.Q ∧ P' = liftP n P ∧ Q' = liftP n Q ⇒
        rmcorr M q P opt Q ⇒
        rmcorr (mrInst n M) q P' opt Q', Thm)),
    (("registerMachine", "mrInst_correct_kN"),
     (⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
        Q' = liftP_V n Q (λrs. rs k = N) ⇒
        rmcorr M q P opt Q ⇒
        rmcorr (mrInst n M) q P' opt Q', Thm)),
    (("registerMachine", "mrInst_correct_V"),
     (⊢ ∀RS.
            wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs = RS) ∧
            Q' = liftP_V n Q (λrs. ∀k. nfst k ≠ n ⇒ rs k = RS k) ⇒
            rmcorr M q P opt Q ⇒
            rmcorr (mrInst n M) q P' opt Q', Thm))]: data list
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        liftP 1 (λrs. rs (HD f.In) = N) ∧
        (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 (λrs. rs f.Out = Op) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ HD f.In) = N)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ HD f.In) = N)

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        liftP 1 (λrs. rs (HD f.In) = N) ∧
        (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 (λrs. rs f.Out = Op) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
   : proof
> > # poly: : error: Type error in function application.
   Function: e : tactic -> proof
   Argument: () : unit
   Reason:
      Can't unify goal -> goal list * validation to {} (Incompatible types)
Found near e ()
Static Errors
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        liftP 1 (λrs. rs (HD f.In) = N) ∧
        (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 (λrs. rs f.Out = Op) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # poly: : error: Type error in function application.
   Function: e : tactic -> proof
   Argument: () : unit
   Reason:
      Can't unify goal -> goal list * validation to {} (Incompatible types)
Found near e ()
Static Errors
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
       rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
         NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
         NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N) NONE
          (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0 (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P' Q'.
            (∀s. s (HD (MAP (λr. 1 ⊗ r) f.In)) = N ⇒ P' s) ∧
            (∀s. Q' s ⇒ s (1 ⊗ f.Out) = Op) ∧
            rmcorr (mrInst 1 f) f.q0 P' NONE Q'
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0 (λrs. rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
       rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
         NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
         NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
              (0 ⊗ g.q0)
              (λrs.
                   rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
                   ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
       rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
         NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
         NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P' Q'.
            (∀s.
                 s (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 (∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ s k = 0) ⇒
                 P' s) ∧ (∀s. Q' s ⇒ s (1 ⊗ f.Out) = Op) ∧
            rmcorr (mrInst 1 f) f.q0 P' NONE Q'
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
       rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
         NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
         NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> # > OK..
val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ [0;32mrs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   : proofs
> > # # # # # # # # # val it =
   Proof manager status: 4 proofs.
   4. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   3. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        liftP 1 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) ∧
        (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 (λrs. rs f.Out = Op) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        liftP 1 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) ∧
        (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 (λrs. rs f.Out = Op) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   
   : proof
> liftP_def;
val it = ⊢ ∀n P. liftP n P = (λrs. P (λr. rs (n ⊗ r))): thm
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
       rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
         NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
         NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        liftP 1 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) ∧
        (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 (λrs. rs f.Out = Op) ∧
        rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> > # OK..

Exception raised at BasicProvers.suffices_by:
suffices_by's tactic failed to prove goal on line 2656
Exception-
   HOL_ERR
     {message = "suffices_by's tactic failed to prove goal on line 2656",
      origin_function = "suffices_by", origin_structure = "BasicProvers"}
   raised
> val it = (): unit
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
    7.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> val it = (): unit
> val it = (): unit
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        ((∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0) ⇒
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        ((∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0) ⇒
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> > # OK..
metis: r[+0+25]+0+0+0+0+0+0+0+0+0+1+0+0+0+0+0+0+3+0+0+1+3+0+1+0+4+3+5+0+0+4+0+2+2+0+5+1+0+0+24+8+1+3+3+8+4+8+2+34+6+4+10+1+0+6+8+6+11+7+34+2+8+2+2+2+2+37+2+5+3+7+2+4+1+0+4+0+3+5+3+48+48+11+12+1+0+13+14+3+4+2+3+11+48+7+13+13+0+5+6+4+6+12+8+0+10+10+8+5+5+5+5+5+2+5+17+67+79+6+6+6+6+11+56+82+6+35+6+69+18+12+80+12+0+10+1+1+5+16+8+8+0+12+124+85+88+58+59+78+61+50+32+32+12+12+11+40+21+85+74+143+0+0+10+17+9+9+11+11+11+22r+67+2+1+94+21+65+2+12+10+28+12+6+10+41+11+6+11+4+0+10+133+150+10+18+15+68+12+29+20+20+27+1+16+180+0+40+66+23+0+35+10+92+100+111+3+12+26+95+10+61+64+25r+60+10+87+159+133+9+23+16+15+13+3+27+20+7+66+62+14+199+0+0+0+17+17+0+229+98+16+15+76+4+12
Exception raised at folTools.FOL_SOLVER:
Time exception raised
Exception-
   HOL_ERR
     {message = "Time exception raised", origin_function = "FOL_SOLVER",
      origin_structure = "folTools"} raised
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        ((∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0) ⇒
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        ((∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0) ⇒
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  t = []
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  f.In = h::t
   ------------------------------------
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)
   
   : proof
> > # OK..

Exception raised at BasicProvers.suffices_by:
suffices_by's tactic failed to prove goal on line 2656
Exception-
   HOL_ERR
     {message = "suffices_by's tactic failed to prove goal on line 2656",
      origin_function = "suffices_by", origin_structure = "BasicProvers"}
   raised
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> find"<=>";
val it = []: data list
> find"imp";
val it =
   [(("ConseqConv", "false_imp"), (⊢ ∀t. F ⇒ t, Thm)),
    (("ConseqConv", "IMP_CLAUSES_FX"), (⊢ ∀t. F ⇒ t ⇔ T, Thm)),
    (("ConseqConv", "IMP_CLAUSES_TX"), (⊢ ∀t. T ⇒ t ⇔ t, Thm)),
    (("ConseqConv", "IMP_CLAUSES_XF"), (⊢ ∀t. t ⇒ F ⇔ ¬t, Thm)),
    (("ConseqConv", "IMP_CLAUSES_XT"), (⊢ ∀t. t ⇒ T ⇔ T, Thm)),
    (("ConseqConv", "IMP_CLAUSES_XX"), (⊢ ∀t. t ⇒ t ⇔ T, Thm)),
    (("ConseqConv", "IMP_CONG_cond"),
     (⊢ ∀c x x' y y'.
            (c ⇒ x' ⇒ x) ∧ (¬c ⇒ y' ⇒ y) ⇒
            (if c then x' else y') ⇒
            if c then x else y, Thm)),
    (("ConseqConv", "IMP_CONG_cond_simple"),
     (⊢ ∀c x x' y y'.
            (x' ⇒ x) ∧ (y' ⇒ y) ⇒ (if c then x' else y') ⇒ if c then x else y,
      Thm)),
    (("ConseqConv", "IMP_CONG_conj_strengthen"),
     (⊢ ∀x x' y y'. (y ⇒ x' ⇒ x) ∧ (x' ⇒ y' ⇒ y) ⇒ x' ∧ y' ⇒ x ∧ y, Thm)),
    (("ConseqConv", "IMP_CONG_conj_weaken"),
     (⊢ ∀x x' y y'. (y ⇒ x ⇒ x') ∧ (x' ⇒ y ⇒ y') ⇒ x ∧ y ⇒ x' ∧ y', Thm)),
    (("ConseqConv", "IMP_CONG_disj_strengthen"),
     (⊢ ∀x x' y y'. (¬y ⇒ x' ⇒ x) ∧ (¬x' ⇒ y' ⇒ y) ⇒ x' ∨ y' ⇒ x ∨ y, Thm)),
    (("ConseqConv", "IMP_CONG_disj_weaken"),
     (⊢ ∀x x' y y'. (¬y ⇒ x ⇒ x') ∧ (¬x' ⇒ y ⇒ y') ⇒ x ∨ y ⇒ x' ∨ y', Thm)),
    (("ConseqConv", "IMP_CONG_imp_strengthen"),
     (⊢ ∀x x' y y'. (x ⇒ y' ⇒ y) ∧ (¬y' ⇒ x ⇒ x') ⇒ (x' ⇒ y') ⇒ x ⇒ y, Thm)),
    (("ConseqConv", "IMP_CONG_imp_weaken"),
     (⊢ ∀x x' y y'. (x ⇒ y ⇒ y') ∧ (¬y' ⇒ x' ⇒ x) ⇒ (x ⇒ y) ⇒ x' ⇒ y', Thm)),
    (("ConseqConv", "IMP_CONG_simple_imp_strengthen"),
     (⊢ ∀x x' y y'. (x ⇒ x') ∧ (x' ⇒ y' ⇒ y) ⇒ (x' ⇒ y') ⇒ x ⇒ y, Thm)),
    (("ConseqConv", "IMP_CONG_simple_imp_weaken"),
     (⊢ ∀x x' y y'. (x' ⇒ x) ∧ (x' ⇒ y ⇒ y') ⇒ (x ⇒ y) ⇒ x' ⇒ y', Thm)),
    (("ConseqConv", "true_imp"), (⊢ ∀t. t ⇒ T, Thm)),
    (("arithmetic", "DIV_0_IMP_LT"),
     (⊢ ∀b n. 1 < b ∧ n DIV b = 0 ⇒ n < b, Thm)),
    (("arithmetic", "EXP_BASE_LEQ_MONO_IMP"),
     (⊢ ∀n m b. 0 < b ∧ m ≤ n ⇒ b ** m ≤ b ** n, Thm)),
    (("arithmetic", "EXP_BASE_LEQ_MONO_SUC_IMP"),
     (⊢ m ≤ n ⇒ SUC b ** m ≤ SUC b ** n, Thm)),
    (("arithmetic", "LESS_CASES_IMP"),
     (⊢ ∀m n. ¬(m < n) ∧ m ≠ n ⇒ n < m, Thm)),
    (("arithmetic", "LESS_EQ_IMP_LESS_SUC"),
     (⊢ ∀n m. n ≤ m ⇒ n < SUC m, Thm)),
    (("arithmetic", "LESS_IMP_LESS_ADD"),
     (⊢ ∀n m. n < m ⇒ ∀p. n < m + p, Thm)),
    (("arithmetic", "LESS_IMP_LESS_OR_EQ"), (⊢ ∀m n. m < n ⇒ m ≤ n, Thm)),
    (("arithmetic", "ONE_LT_MULT_IMP"),
     (⊢ ∀p q. 1 < p ∧ 0 < q ⇒ 1 < p * q, Thm)),
    (("bool", "ABS_SIMP"), (⊢ ∀t1 t2. (λx. t1) t2 = t1, Thm)),
    (("bool", "AND_IMP_INTRO"),
     (⊢ ∀t1 t2 t3. t1 ⇒ t2 ⇒ t3 ⇔ t1 ∧ t2 ⇒ t3, Thm)),
    (("bool", "BOTH_EXISTS_IMP_THM"),
     (⊢ ∀P Q. (∃x. P ⇒ Q) ⇔ (∀x. P) ⇒ ∃x. Q, Thm)),
    (("bool", "BOTH_FORALL_IMP_THM"),
     (⊢ ∀P Q. (∀x. P ⇒ Q) ⇔ (∃x. P) ⇒ ∀x. Q, Thm)),
    (("bool", "COND_EXPAND_IMP"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ (b ⇒ t1) ∧ (¬b ⇒ t2), Thm)),
    (("bool", "DISJ_EQ_IMP"), (⊢ ∀A B. A ∨ B ⇔ ¬A ⇒ B, Thm)),
    (("bool", "DISJ_IMP_THM"),
     (⊢ ∀P Q R. P ∨ Q ⇒ R ⇔ (P ⇒ R) ∧ (Q ⇒ R), Thm)),
    (("bool", "EQ_IMP_THM"),
     (⊢ ∀t1 t2. (t1 ⇔ t2) ⇔ (t1 ⇒ t2) ∧ (t2 ⇒ t1), Thm)),
    (("bool", "EXISTS_SIMP"), (⊢ ∀t. (∃x. t) ⇔ t, Thm)),
    (("bool", "F_IMP"), (⊢ ∀t. ¬t ⇒ t ⇒ F, Thm)),
    (("bool", "FORALL_SIMP"), (⊢ ∀t. (∀x. t) ⇔ t, Thm)),
    (("bool", "IMP_ANTISYM_AX"),
     (⊢ ∀t1 t2. (t1 ⇒ t2) ⇒ (t2 ⇒ t1) ⇒ (t1 ⇔ t2), Thm)),
    (("bool", "IMP_CLAUSES"),
     (⊢ ∀t.
            (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧
            (t ⇒ F ⇔ ¬t), Thm)),
    (("bool", "IMP_CONG"),
     (⊢ ∀x x' y y'. (x ⇔ x') ∧ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y'), Thm)),
    (("bool", "IMP_CONJ_THM"),
     (⊢ ∀P Q R. P ⇒ Q ∧ R ⇔ (P ⇒ Q) ∧ (P ⇒ R), Thm)),
    (("bool", "IMP_DISJ_THM"), (⊢ ∀A B. A ⇒ B ⇔ ¬A ∨ B, Thm)),
    (("bool", "IMP_F"), (⊢ ∀t. (t ⇒ F) ⇒ ¬t, Thm)),
    (("bool", "IMP_F_EQ_F"), (⊢ ∀t. t ⇒ F ⇔ (t ⇔ F), Thm)),
    (("bool", "LEFT_EXISTS_IMP_THM"),
     (⊢ ∀P Q. (∃x. P x ⇒ Q) ⇔ (∀x. P x) ⇒ Q, Thm)),
    (("bool", "LEFT_FORALL_IMP_THM"),
     (⊢ ∀P Q. (∀x. P x ⇒ Q) ⇔ (∃x. P x) ⇒ Q, Thm)),
    (("bool", "MONO_IMP"), (⊢ (y ⇒ x) ∧ (z ⇒ w) ⇒ (x ⇒ z) ⇒ y ⇒ w, Thm)),
    (("bool", "NOT_IMP"), (⊢ ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B, Thm)),
    (("bool", "OR_IMP_THM"), (⊢ ∀A B. (A ⇔ B ∨ A) ⇔ B ⇒ A, Thm)),
    (("bool", "RIGHT_EXISTS_IMP_THM"),
     (⊢ ∀P Q. (∃x. P ⇒ Q x) ⇔ P ⇒ ∃x. Q x, Thm)),
    (("bool", "RIGHT_FORALL_IMP_THM"),
     (⊢ ∀P Q. (∀x. P ⇒ Q x) ⇔ P ⇒ ∀x. Q x, Thm)),
    (("bool", "UEXISTS_SIMP"), (⊢ (∃!x. t) ⇔ t ∧ ∀x y. x = y, Thm)),
    (("combin", "UPDATE_APPLY_IMP_ID"),
     (⊢ ∀f b a. f a = b ⇒ f⦇a ↦ b⦈ = f, Thm)),
    (("list", "ALL_DISTINCT_EL_IMP"),
     (⊢ ∀l n1 n2.
            ALL_DISTINCT l ∧ n1 < LENGTH l ∧ n2 < LENGTH l ⇒
            (EL n1 l = EL n2 l ⇔ n1 = n2), Thm)),
    (("list", "ALL_DISTINCT_FILTER_EL_IMP"),
     (⊢ ∀P l n1 n2.
            ALL_DISTINCT (FILTER P l) ∧ n1 < LENGTH l ∧ n2 < LENGTH l ∧
            P (EL n1 l) ∧ EL n1 l = EL n2 l ⇒
            n1 = n2, Thm)),
    (("list", "EL_simp"),
     (⊢ EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l) ∧
        EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l), Thm)),
    (("list", "EL_simp_restricted"),
     (⊢ EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls ∧
        EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls, Thm)),
    (("list", "EVERY_FILTER_IMP"),
     (⊢ ∀P1 P2 l. EVERY P1 l ⇒ EVERY P1 (FILTER P2 l), Thm)),
    (("list", "EVERY_SIMP"), (⊢ ∀c l. EVERY (λx. c) l ⇔ l = [] ∨ c, Thm)),
    (("list", "EXISTS_SIMP"), (⊢ ∀c l. EXISTS (λx. c) l ⇔ l ≠ [] ∧ c, Thm)),
    (("list", "IMP_EVERY_LUPDATE"),
     (⊢ ∀xs h i. P h ∧ EVERY P xs ⇒ EVERY P (LUPDATE h i xs), Thm)),
    (("list", "LIST_REL_APPEND_IMP"),
     (⊢ ∀xs ys xs1 ys1.
            LIST_REL P (xs ⧺ xs1) (ys ⧺ ys1) ∧ LENGTH xs = LENGTH ys ⇒
            LIST_REL P xs ys ∧ LIST_REL P xs1 ys1, Thm)),
    (("list", "LIST_REL_MEM_IMP"),
     (⊢ ∀xs ys P x. LIST_REL P xs ys ∧ MEM x xs ⇒ ∃y. MEM y ys ∧ P x y, Thm)),
    (("list", "MEM_dropWhile_IMP"),
     (⊢ ∀P ls x. MEM x (dropWhile P ls) ⇒ MEM x ls, Thm)),
    (("patternMatches", "PMATCH_ROW_COND_EX_IMP_REWRITE"),
     (⊢ ∀v p g p' g' RES.
            PMATCH_ROW_COND_EX v p g ⇒
            (∀x. g x ⇒ ((∃x'. p' x' = p x ∧ g' x') ⇔ RES)) ⇒
            (PMATCH_ROW_COND_EX v p' g' ⇔ RES), Thm)),
    (("pred_set", "BIJ_IMP_11"),
     (⊢ BIJ f 𝕌(:α) 𝕌(:β) ⇒ ∀x y. f x = f y ⇔ x = y, Thm)),
    (("pred_set", "BIJ_INSERT_IMP"),
     (⊢ ∀f e s t.
            e ∉ s ∧ BIJ f (e INSERT s) t ⇒
            ∃u. f e INSERT u = t ∧ f e ∉ u ∧ BIJ f s u, Thm)),
    (("pred_set", "BIJ_SYM_IMP"),
     (⊢ ∀s t. (∃f. BIJ f s t) ⇒ ∃g. BIJ g t s, Thm)),
    (("pred_set", "IN_EQ_UNIV_IMP"), (⊢ ∀s. s = 𝕌(:α) ⇒ ∀v. v ∈ s, Thm)),
    (("pred_set", "SURJ_IMP_INJ"),
     (⊢ ∀s t. (∃f. SURJ f s t) ⇒ ∃g. INJ g t s, Thm)),
    (("prim_rec", "LESS_SUC_IMP"), (⊢ ∀m n. m < SUC n ⇒ m ≠ n ⇒ m < n, Thm)),
    (("prim_rec", "SIMP_REC"),
     (⊢ ∀x f' n. ∃g. SIMP_REC_REL g x f' (SUC n) ∧ SIMP_REC x f' n = g n,
      Def)),
    (("prim_rec", "SIMP_REC_EXISTS"),
     (⊢ ∀x f n. ∃fun. SIMP_REC_REL fun x f n, Thm)),
    (("prim_rec", "SIMP_REC_REL"),
     (⊢ ∀fun x f n.
            SIMP_REC_REL fun x f n ⇔
            fun 0 = x ∧ ∀m. m < n ⇒ fun (SUC m) = f (fun m), Def)),
    (("prim_rec", "SIMP_REC_REL_UNIQUE"),
     (⊢ ∀x f g1 g2 m1 m2.
            SIMP_REC_REL g1 x f m1 ∧ SIMP_REC_REL g2 x f m2 ⇒
            ∀n. n < m1 ∧ n < m2 ⇒ g1 n = g2 n, Thm)),
    (("prim_rec", "SIMP_REC_REL_UNIQUE_RESULT"),
     (⊢ ∀x f n. ∃!y. ∃g. SIMP_REC_REL g x f (SUC n) ∧ y = g n, Thm)),
    (("prim_rec", "SIMP_REC_THM"),
     (⊢ ∀x f.
            SIMP_REC x f 0 = x ∧
            ∀m. SIMP_REC x f (SUC m) = f (SIMP_REC x f m), Thm)),
    (("quantHeuristics", "DISJ_IMP_INTRO"),
     (⊢ (∀x. P x ∨ Q x) ⇒ (¬P y ⇒ Q y) ∧ (¬Q y ⇒ P y), Thm)),
    (("quantHeuristics", "GUESS_RULES_IMP"),
     (⊢ (GUESS_FORALL_POINT i (λx. P x) ⇒
         GUESS_EXISTS_POINT i (λx. P x ⇒ Q x)) ∧
        (GUESS_EXISTS_POINT i (λx. Q x) ⇒
         GUESS_EXISTS_POINT i (λx. P x ⇒ Q x)) ∧
        (GUESS_FORALL i (λx. P x) ∧ GUESS_EXISTS i (λx. Q x) ⇒
         GUESS_EXISTS i (λx. P x ⇒ Q x)) ∧
        (GUESS_FORALL_GAP i (λx. P x) ∧ GUESS_EXISTS_GAP i (λx. Q x) ⇒
         GUESS_EXISTS_GAP i (λx. P x ⇒ Q x)) ∧
        (GUESS_EXISTS (λxxx. iK) (λx. P x) ∧
         GUESS_FORALL (λxxx. iK) (λx. Q x) ⇒
         GUESS_FORALL (λxxx. iK) (λx. P x ⇒ Q x)) ∧
        (GUESS_EXISTS i (λx. P x) ⇒ GUESS_FORALL i (λx. P x ⇒ q)) ∧
        (GUESS_FORALL i (λx. Q x) ⇒ GUESS_FORALL i0;32mv2. P v2), Thm)), ...]: data list
> Compilation interrupted

> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> find"FUN_EQ;
# ;
poly: : error: no matching quote found on this line
Static Errors
> find"FUN_EQ";
val it =
   [(("bool", "FUN_EQ_THM"), (⊢ ∀f g. f = g ⇔ ∀x. f x = g x, Thm)),
    (("list", "GENLIST_FUN_EQ"),
     (⊢ ∀n f g. GENLIST f n = GENLIST g n ⇔ ∀x. x < n ⇒ f x = g x, Thm))]:
   data list
> DB.match[] ``_ /\ _ <=> _ /\ _``;
val it = (): unit
> val it =
   [(("bool", "AND_CONG"),
     (⊢ ∀P P' Q Q'. (Q ⇒ (P ⇔ P')) ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q'),
      Thm)),
    (("bool", "CONJ_ASSOC"),
     (⊢ ∀t1 t2 t3. t1 ∧ t2 ∧ t3 ⇔ (t1 ∧ t2) ∧ t3, Thm)),
    (("bool", "CONJ_COMM"), (⊢ ∀t1 t2. t1 ∧ t2 ⇔ t2 ∧ t1, Thm)),
    (("bool", "CONJ_SYM"), (⊢ ∀t1 t2. t1 ∧ t2 ⇔ t2 ∧ t1, Thm)),
    (("bool", "LEFT_AND_CONG"),
     (⊢ ∀P P' Q Q'. (P ⇔ P') ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q'), Thm)),
    (("list", "LIST_REL_APPEND"),
     (⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇔
        LIST_REL R (l1 ⧺ l3) (l2 ⧺ l4) ∧ LENGTH l1 = LENGTH l2 ∧
        LENGTH l3 = LENGTH l4, Thm)),
    (("marker", "move_left_conj"),
     (⊢ ∀p q m.
            (p ∧ stmarker m ⇔ stmarker m ∧ p) ∧
            ((stmarker m ∧ p) ∧ q ⇔ stmarker m ∧ p ∧ q) ∧
            (p ∧ stmarker m ∧ q ⇔ stmarker m ∧ p ∧ q), Thm)),
    (("marker", "move_right_conj"),
     (⊢ ∀p q m.
            (stmarker m ∧ p ⇔ p ∧ stmarker m) ∧
            (p ∧ q ∧ stmarker m ⇔ (p ∧ q) ∧ stmarker m) ∧
            ((p ∧ stmarker m) ∧ q ⇔ (p ∧ q) ∧ stmarker m), Thm)),
    (("rich_list", "EVERY2_APPEND"),
     (⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇔
        LIST_REL R (l1 ⧺ l3) (l2 ⧺ l4) ∧ LENGTH l1 = LENGTH l2 ∧
        LENGTH l3 = LENGTH l4, Thm))]: data list
> DB.match[] ``A /\ _ <=> A /\ _``;
val it = (): unit
> val it = []: data list
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> val it = (): unit
> > # poly: : error: Type error in function application.
   Function: >> :
      (term quotation, 'a) gentactic * tactic ->
        (term quotation, 'a) gentactic
   Argument:
      (
         (fn q => BasicProvers.byA (q, ...)),
         [
            QUOTE
            " (*#loc 2657 5*)(\226\136\128k. k \226\137\160 1 \226\138\151 h \226\136\167 nfst k = 1 \226\135\146 rs k = 0) = (\226\136\128k. k \226\137\160 h \226\135\146 rs (1 \226\138\151 k) = 0) "
            ]
         ) : (term quotation -> tactic) * 'a frag list
   Reason:
      Can't unify goal list * (thm list -> 'a) to
         goal -> goal list * validation (Incompatible types)
Found near
  e
  (
  (fn q => BasicProvers.byA (...)) >>
  [
     QUOTE
     " (*#loc 2657 5*)(\226\136\128k. k \226\137\160 1 \226\138\151 h \226\136\167 nfst k = 1 \226\135\146 rs k = 0) = (\226\136\128k. k \226\137\160 h \226\135\146 rs (1 \226\138\151 k) = 0) "
     ])
poly: : error: Type error in function application.
   Function: e : tactic -> proof
   Argument:
      (
      (fn q => BasicProvers.byA (q, ...)) >>
      [
         QUOTE
         " (*#loc 2657 5*)(\226\136\128k. k \226\137\160 1 \226\138\151 h \226\136\167 nfst k = 1 \226\135\146 rs k = 0) = (\226\136\128k. k \226\137\160 h \226\135\146 rs (1 \226\138\151 k) = 0) "
         ]) : (term quotation, 'a) gentactic
   Reason:
      Can't unify term frag list to term list * term (Incompatible types)
Found near
  e
  (
  (fn q => BasicProvers.byA (...)) >>
  [
     QUOTE
     " (*#loc 2657 5*)(\226\136\128k. k \226\137\160 1 \226\138\151 h \226\136\167 nfst k = 1 \226\135\146 rs k = 0) = (\226\136\128k. k \226\137\160 h \226\135\146 rs (1 \226\138\151 k) = 0) "
     ])
Static Errors
> val it = (): unit
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

2 subgoals
   : proof
> DB.match[] ``!_. _ <=> !_. _``;
val it = (): unit
> val it = []: data list
> DB.match[] ``!_. <=> !_.``;
val it = (): unit
> Don't expect to find a <=> in this position after a . (end binding)
on line 6, characters 17-19 and at line 6, character 15.
Exception-
   HOL_ERR
     {message =
      "at line 6, character 15:\nDon't expect to find a <=> in this position after a . (end binding)\non line 6, characters 17-19 and at line 6, character 15.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> DB.match[] ``! _ <=> ! _``;
val it = (): unit
> Don't expect to find a <end of input> in this position after a !
in compiler-generated text and at line 8, character 21.
Exception-
   HOL_ERR
     {message =
      "at line 8, character 21:\nDon't expect to find a <end of input> in this position after a !\nin compiler-generated text and at line 8, character 21.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> DB.match[] ``!_ _ <=> !_ _``;
val it = (): unit
> Don't expect to find a <end of input> in this position after a !
in compiler-generated text and at line 10, character 22.
Exception-
   HOL_ERR
     {message =
      "at line 10, character 22:\nDon't expect to find a <end of input> in this position after a !\nin compiler-generated text and at line 10, character 22.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> > # OK..

Exception raised at Tactic.STRIP_TAC:

Exception-
   HOL_ERR
     {message = "", origin_function = "STRIP_TAC", origin_structure =
      "Tactic"} raised
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

2 subgoals
   : proof
> > # OK..

Goal proved.
 [......]
⊢ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> > # OK..

Goal proved.
 [.]
⊢ rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
  rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

Goal proved.
 [......]
⊢ rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
  rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

Goal proved.
 [.......]
⊢ (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) =
  (λrs. rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0)

Goal proved.
 [......]
⊢ (λrs.
       rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
       ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
  (λrs. rs (1 ⊗ HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs (1 ⊗ k) = 0)

Goal proved.
 [......]
⊢ (λrs.
       rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
       ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
  liftP 1 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) ∧
  (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 (λrs. rs f.Out = Op) ∧
  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
    (λrs. rs f.Out = Op)

Goal proved.
 [......]
⊢ ∃P Q.
      (λrs.
           rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
           ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
      liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
      rmcorr f f.q0 P NONE Q

Goal proved.
 [......]
⊢ rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
    (λrs.
         rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
         ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) NONE
    (λrs. rs (1 ⊗ f.Out) = Op)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In))
              (0 ⊗ g.q0)
              (λrs.
                   rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
                   ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE Q ∧
            rmcorr
              (msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
              (1 ⊗ 0) Q NONE
              (λrs.
                   rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                   ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) ∧
        rmcorr
          (msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (1 ⊗ 0)
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (1 ⊗ 0) (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> rmcorr_weakening;
val it =
   ⊢ (∀s. P s ⇒ P' s) ∧ (∀s. Q' s ⇒ Q s) ∧ rmcorr m q0 P' q Q' ⇒
     rmcorr m q0 P q Q: thm
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        2 ⊗ g.Out ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ 2 ⊗ g.Out ≠ 0 ⊗ 1 ∧
        HD (MAP (λr. 1 ⊗ r) f.In) ≠ 0 ⊗ 1 ∧
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
   : proof
> > # poly: : error: Value or constructor (ect_2) has not been declared Found near e (ect_2)
Static Errors
> > # OK..
3 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        HD (MAP (λr. 1 ⊗ r) f.In) ≠ 0 ⊗ 1
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        2 ⊗ g.Out ≠ HD (MAP (λr. 1 ⊗ r) f.In)

3 subgoals
   : proof
> > # OK..

Goal proved.
 [......] ⊢ 2 ⊗ g.Out ≠ HD (MAP (λr. 1 ⊗ r) f.In)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        HD (MAP (λr. 1 ⊗ r) f.In) ≠ 0 ⊗ 1

2 subgoals
   : proof
> > # OK..

Goal proved.
 [......] ⊢ HD (MAP (λr. 1 ⊗ r) f.In) ≠ 0 ⊗ 1

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
        (λrs.
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
             ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧
             rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        HD (MAP (λr. 1 ⊗ r) f.In) ≠ 0 ⊗ 1

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        HD (MAP (λr. 1 ⊗ r) f.In) ≠ 0 ⊗ 1
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        2 ⊗ g.Out ≠ HD (MAP (λr. 1 ⊗ r) f.In)

3 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        2 ⊗ g.Out ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ 2 ⊗ g.Out ≠ 0 ⊗ 1 ∧
        HD (MAP (λr. 1 ⊗ r) f.In) ≠ 0 ⊗ 1 ∧
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs.
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                 ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧
                 rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N')
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
       rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
         NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
         NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (1 ⊗ 0) (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> dup_correct_2;
val it =
   ⊢ ∀r1 r2 r3 RS.
         r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs r3 = 0 ∧ rs r1 = N) ∧
         Q = (λrs. rs r3 = 0 ∧ rs r1 = N ∧ rs r2 = N) ⇒
         rmcorr (dup r1 r2 r3) 0 P NONE Q: thm
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # Proof of 

∀r1 r2 r3 RS.
    RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
    Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
    rmcorr (dup r1 r2 r3) 0 P NONE Q

failed.
Failed to prove theorem dup_correct_V.

Exception raised at Tactic.MATCH_MP_TAC:
No match (THEN1 on line 1708) (THEN1 on line 1715)
Exception-
   HOL_ERR
     {message = "No match (THEN1 on line 1708) (THEN1 on line 1715)",
      origin_function = "MATCH_MP_TAC", origin_structure = "Tactic"} raised
> > # # # # # val it =
   Proof manager status: 5 proofs.
   5. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   4. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀r1 r2 r3 RS.
            RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
            Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
            rmcorr (dup r1 r2 r3) 0 P NONE Q
   : proofs
> > # # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃Q q2.
            rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME q2) Q ∧
            rmcorr (dup r1 r2 r3) q2 Q NONE
              (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> correct1_rmcorr_def;
val it =
   ⊢ ∀f M.
         correct1_rmcorr f M ⇔
         ∀inp. rmcorr M M.q0 (λrs. HD M.In = inp) NONE (λrs. M.Out = f inp):
   thm
> correct1_rmcorr_V_def;
val it =
   ⊢ ∀f M.
         correct1_rmcorr_V f M ⇔
         ∀inp.
             rmcorr M M.q0 (λrs. HD M.In = inp ∧ ∀k. k ≠ HD M.In ⇒ rs k = 0)
               NONE (λrs. M.Out = f inp): thm
> mrInst_rmcorr;
poly: : error: Value or constructor (mrInst_rmcorr) has not been declared
Found near mrInst_rmcorr
Static Errors
> mrInst_correct;
val it =
   ⊢ wfrm M ∧ q ∈ M.Q ∧ P' = liftP n P ∧ Q' = liftP n Q ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': thm
> mrInst_correct2;
poly: : error: Value or constructor (mrInst_correct2) has not been declared
Found near mrInst_correct2
Static Errors
> mrInst_correct_V;
val it =
   ⊢ ∀RS.
         wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs = RS) ∧
         Q' = liftP_V n Q (λrs. ∀k. nfst k ≠ n ⇒ rs k = RS k) ⇒
         rmcorr M q P opt Q ⇒
         rmcorr (mrInst n M) q P'mrInst_correct_V; opt Q': thm
>liftP_def; 
poly: : error: Value or constructor (V) has not been declared Found near V
Static Errors
> V; opt Q': thm
>liftP_def;
poly: : error: Value or constructor (V) has not been declared Found near V
Static Errors
> V; opt Q': thm
> liftP_def;
poly: : error: Value or constructor (V) has not been declared Found near V
Static Errors
> V; opt Q': thm
> liftP;
poly: : error: Value or constructor (V) has not been declared Found near V
Static Errors
> liftP_V;
poly: : error: Value or constructor (liftP_V) has not been declared Found near liftP_V
Static Errors
> liftP_def;
val it = ⊢ ∀n P. liftP n P = (λrs. P (λr. rs (n ⊗ r))): thm
> mrInst_correct_V;# > val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃Q q2.
            rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME q2) Q ∧
            rmcorr (dup r1 r2 r3) q2 Q NONE
              (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀r1 r2 r3 RS.
       RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
       Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
       rmcorr (dup r1 r2 r3) 0 P NONE Q: proof
> > # # # # # # # # # val it =
   Proof manager status: 6 proofs.
   6. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   5. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   4. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀r1 r2 r3 RS.
            RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
            Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
            rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+2+0+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # # # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> val it = (): unit
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
   ------------------------------------
        (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
    7.  k ≠ 1 ⊗ h
    8.  nfst k = 1
   ------------------------------------
        rs k = 0
   
   : proof
> # val it = ⊢ ∀t1 t2. (t1 ⇔ t2) ⇔ (t1 ⇒ t2) ∧ (t2 ⇒ t1): thm
> > # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2699
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2699",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..
metis: r[+0+6]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
    7.  k ≠ 1 ⊗ h
    8.  nfst k = 1
    9.  k = p ⊗ q
   ------------------------------------
        rs k = 0
   
   : proof
> > # OK..

Goal proved.
 [..........] ⊢ rs k = 0

Goal proved.
 [.........] ⊢ rs k = 0

Goal proved.
 [......]
⊢ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    4.  rmcorr f f.q0 (λrs. rs h = N ∧ ∀k. k ≠ h ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    5.  f.In = [h]
    6.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   
   : proof
> > # OK..

Goal proved.
 [.]
⊢ rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
  rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

Goal proved.
 [......]
⊢ rs (1 ⊗ h) = N ∧ (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔
  rs (1 ⊗ h) = N ∧ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0

Goal proved.
 [......]
⊢ rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
    (λrs.
         rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
         ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0) NONE
    (λrs. rs (1 ⊗ f.Out) = Op)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
          (0 ⊗ g.q0)
          (λrs.
               rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
               ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
               ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  LENGTH g.In = 1
    3.  LENGTH f.In = 1
    4.  rmcorr g g.q0 (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0)
          NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0)
          NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In))
              (0 ⊗ g.q0)
              (λrs.
                   rs (HD (MAP (λr. 2 ⊗ r) g.In)) = M ∧
                   ∀k. k ≠ HD (MAP (λr. 2 ⊗ r) g.In) ⇒ rs k = 0) NONE Q ∧
            rmcorr
              (msInst 1 (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)))
              (1 ⊗ 0) Q NONE
              (λrs.
                   rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                   ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> # > OK..
val it =
   Proof manager status: 5 proofs.
   5. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   4. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀r1 r2 r3 RS.
            RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
            Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
            rmcorr (dup r1 r2 r3) 0 P NONE Q
   : proofs
> # > OK..
val it =
   Proof manager status: 4 proofs.
   4. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   3. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   : proofs
> correct1_rmcorr;
poly: : error: ; expected but ) was found
Static Errors
> 0)
   : proofs
> correct1_rmcorr_def;
poly: : error: ; expected but ) was found
Static Errors
> 0)
   : proofs
> correct1_rmcorr_V;
poly: : error: ; expected but ) was found
Static Errors
> 0)
   : proofs
> correct1_rmcorr_def;
poly: : error: ; expected but ) was found
Static Errors
> 0)
   : proofs
> correct1_rmcorr_V_def;
poly: : error: ; expected but ) was found
Static Errors
> ;
> ;
> 3;
val it = 3: int
> 0)
   : proofs
> correct1_rmcorr_V_def;
poly: : error: ; expected but ) was found
Static Errors
> 3;
val it = 3: int
> correct1_rmcorr_V_def;
val it =
   ⊢ ∀f M.
         correct1_rmcorr_V f M ⇔
         ∀inp.
             rmcorr M M.q0 (λrs. HD M.In = inp ∧ ∀k. k ≠ HD M.In ⇒ rs k = 0)
               NONE (λrs. M.Out = f inp): thm
> correct1_rmcorr_def;
val it =
   ⊢ ∀f M.
         correct1_rmcorr f M ⇔
         ∀inp. rmcorr M M.q0 (λrs. HD M.In = inp) NONE (λrs. M.Out = f inp):
   thm
> > # # # # # # # # # val it =
   Proof manager status: 5 proofs.
   5. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   4. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#

Exception raised at Tactical.THEN1:
first subgoal not solved by second tactic (THEN1 on line 2689) (THEN1 on line 2702)
Exception-
   HOL_ERR
     {message =
      "first subgoal not solved by second tactic (THEN1 on line 2689) (THEN1 on line 2702)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> > # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#

Exception raised at Tactical.THEN1:
first subgoal not solved by second tactic (THEN1 on line 2713) (THEN1 on line 2726)
Exception-
   HOL_ERR
     {message =
      "first subgoal not solved by second tactic (THEN1 on line 2713) (THEN1 on line 2726)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> > # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (HD (msInst 2 (mrInst 1 f)).In) = N ∧
               ∀k. k ≠ HD (msInst 2 (mrInst 1 f)).In ∧ nfst k = 1 ⇒ rs k = 0) ∧
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs.
               rs (HD (msInst 2 (mrInst 1 f)).In) = N ∧
               ∀k. k ≠ HD (msInst 2 (mrInst 1 f)).In ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        f.q0 ∈ f.Q

2 subgoals
   : proof
> > # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#

Exception raised at Tactical.THEN1:
goal completely solved by first tactic (THEN1 on line 2693)
Exception-
   HOL_ERR
     {message =
      "goal completely solved by first tactic (THEN1 on line 2693)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#

Goal proved.
 [......] ⊢ f.q0 ∈ f.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 1 f) f.q0
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        f.q0 ∈ f.Q

2 subgoals
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#

Goal proved.
 [......] ⊢ f.q0 ∈ f.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rs (1 ⊗ fin) = N ∧ (∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ fin) = N ∧ ∀k. k ≠ fin ⇒ rs (1 ⊗ k) = 0
   
   : proof
> > # # # OK..
metis: r[+0+6]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  (∀k. k ≠ 1 ⊗ h ∧ nfst k = 1 ⇒ rs k = 0) ⇔ ∀k. k ≠ h ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rs (1 ⊗ fin) = N ∧ (∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ fin) = N ∧ ∀k. k ≠ fin ⇒ rs (1 ⊗ k) = 0
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rs (1 ⊗ fin) = N ∧ (∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        rs (1 ⊗ fin) = N ∧ ∀k. k ≠ fin ⇒ rs (1 ⊗ k) = 0
   
   : proof
> > # # # OK..
metis: r[+0+6]#

Goal proved.
 [......]
⊢ rs (1 ⊗ fin) = N ∧ (∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) ⇔
  rs (1 ⊗ fin) = N ∧ ∀k. k ≠ fin ⇒ rs (1 ⊗ k) = 0

Goal proved.
 [......]
⊢ ∃P Q.
      (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
      liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
      rmcorr f f.q0 P NONE Q

Goal proved.
 [......]
⊢ rmcorr (mrInst 1 f) f.q0
    (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) NONE
    (λrs. rs (1 ⊗ f.Out) = Op)

Goal proved.
 [......]
⊢ rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
    (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) NONE
    (λrs. rs (1 ⊗ f.Out) = Op)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE
              (λrs.
                   rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        DISJOINT {0 ⊗ x | x ∈ g.Q}
          {1 ⊗ x | x = 0 ∨ x = 1 ∨ x = 2 ∨ x = 3 ∨ x = 4 ∨ x = 5}

2 subgoals
   : proof
> > # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#

Goal proved.
 [......]
⊢ DISJOINT {0 ⊗ x | x ∈ g.Q}
    {1 ⊗ x | x = 0 ∨ x = 1 ∨ x = 2 ∨ x = 3 ∨ x = 4 ∨ x = 5}

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE
              (λrs.
                   rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) ∧
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        2 ⊗ g.Out ≠ 1 ⊗ fin ∧ 2 ⊗ g.Out ≠ 0 ⊗ 1 ∧ 1 ⊗ fin ≠ 0 ⊗ 1 ∧
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧ rs (1 ⊗ fin) = N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧ rs (1 ⊗ fin) = N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧ rs (1 ⊗ fin) = N)
   
   : proof
> dup_correct_2;
val it =
   ⊢ ∀r1 r2 r3 RS.
         r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs r3 = 0 ∧ rs r1 = N) ∧
         Q = (λrs. rs r3 = 0 ∧ rs r1 = N ∧ rs r2 = N) ⇒
         rmcorr (dup r1 r2 r3) 0 P NONE Q: thm
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧ rs (1 ⊗ fin) = N')
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        2 ⊗ g.Out ≠ 1 ⊗ fin ∧ 2 ⊗ g.Out ≠ 0 ⊗ 1 ∧ 1 ⊗ fin ≠ 0 ⊗ 1 ∧
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧ rs (1 ⊗ fin) = N')
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) ∧
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE
              (λrs.
                   rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) ∧
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
          NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
          NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃N'.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N') ∧
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N' ∧ rs (1 ⊗ fin) = N')
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) =
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧ rs (1 ⊗ fin) = N)
   
   : proof
> dup_correct_2;
val it =
   ⊢ ∀r1 r2 r3 RS.
         r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs r3 = 0 ∧ rs r1 = N) ∧
         Q = (λrs. rs r3 = 0 ∧ rs r1 = N ∧ rs r2 = N) ⇒
         rmcorr (dup r1 r2 r3) 0 P NONE Q: thm
> > # # # # # val it =
   Proof manager status: 6 proofs.
   6. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   5. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   4. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  g.In = [gin]
         3.  f.In = [fin]
         4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
             (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧ rs (1 ⊗ fin) = N)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀r1 r2 r3 RS.
            RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
            Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
            rmcorr (dup r1 r2 r3) 0 P NONE Q
   : proofs
> > # # # # OK..
2 subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ rs r3 = 0 ∧ rs r1 = N) NONE
          (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME 1)
          (λrs. rs r2 = 0 ∧ rs r3 = 0 ∧ rs r1 = N)

2 subgoals
   : proof
> # > val it =
   Initial goal:
   
   ∀r1 r2 r3 RS.
       RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
       Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
       rmcorr (dup r1 r2 r3) 0 P NONE Q: proof
> > # # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃Q q2.
            rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME q2) Q ∧
            rmcorr (dup r1 r2 r3) q2 Q NONE
              (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ 2 ⇒ rs k = RS k)
          NONE (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME 1)
          (λrs. rs r2 = 0 ∧ ∀k. k ≠ 2 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
    4.  ∀k. k ≠ 2 ⇒ (if r2 = k then rs k + 1 else rs k) = RS k
    5.  k ≠ 2
   ------------------------------------
        rs k = RS k
   
   : proof
> > # OK..
metis: r[+0+9]+0+0+0+1+0+0+0+0+4+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > val it =
   Initial goal:
   
   ∀r1 r2 r3 RS.
       RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
       Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
       rmcorr (dup r1 r2 r3) 0 P NONE Q: proof
> correct1_rmcorr_V;
poly: : error: Value or constructor (correct1_rmcorr_V) has not been declared
Found near correct1_rmcorr_V
Static Errors
> > # # # # # Exception-
   HOL_ERR
     {message =
      "on line 288, characters 2-18:\ncorrect1_rmcorr_V not a known type operator",
      origin_function = "type parser", origin_structure = "Parse"} raised
> # # # # # <<HOL warning: ThmSetData.revise_data: 
  Theorems in set "compute":
    ADD<registerMachine.correct1_rmcorr_V_def>
  invalidated by NewBinding(correct1_rmcorr_V_def)>>
<<HOL warning: GrammarDeltas.revise_data: 
  Grammar-deltas:
    overload_on("correct1_rmcorr_V")
  invalidated by NewConstant(registerMachine$correct1_rmcorr_V)>>
Definition has been stored under "correct1_rmcorr_V_def"
val correct1_rmcorr_V_def =
   ⊢ ∀f M.
         correct1_rmcorr_V f M ⇔
         ∃min.
             M.In = [min] ∧ wfrm M ∧
             ∀inp.
                 rmcorr M M.q0 (λrs. rs min = inp ∧ ∀k. k ≠ min ⇒ rs k = 0)
                   NONE (λrs. M.Out = f inp): thm
> > # # val it =
   Proof manager status: 7 proofs.
   7. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   6. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   5. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old f M1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old g M2 ⇒
            registerMachine$old8->correct1_rmcorr_V<-old (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   4. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  g.In = [gin]
         3.  f.In = [fin]
         4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
             (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧ rs (1 ⊗ fin) = N)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀r1 r2 r3 RS.
            RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
            Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
            rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            correct1_rmcorr_V f M1 ∧ correct1_rmcorr_V g M2 ⇒
            correct1_rmcorr_V (f ∘ g) (Cn M1 M2)
   : proofs
> > # OK..
1 subgoal:
val it =
   
    0.  M1.In = [min]
    1.  wfrm M1
    2.  ∀inp.
            rmcorr M1 M1.q0 (λrs. rs min = inp ∧ ∀k. k ≠ min ⇒ rs k = 0) NONE
              (λrs. M1.Out = f inp)
    3.  M2.In = [min']
    4.  wfrm M2
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. rs min' = inp ∧ ∀k. k ≠ min' ⇒ rs k = 0)
              NONE (λrs. M2.Out = g inp)
   ------------------------------------
        ∃min.
            (Cn M1 M2).In = [min] ∧ wfrm (Cn M1 M2) ∧
            ∀inp.
                rmcorr (Cn M1 M2) (Cn M1 M2).q0
                  (λrs. rs min = inp ∧ ∀k. k ≠ min ⇒ rs k = 0) NONE
                  (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> mrInst_correct_V;
val it =
   ⊢ ∀RS.
         wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs = RS) ∧
         Q' = liftP_V n Q (λrs. ∀k. nfst k ≠ n ⇒ rs k = RS k) ⇒
         rmcorr M q P opt Q ⇒
         rmcorr (mrInst n M) q P' opt Q': thm
> # > val it =
   
    0.  M1.In = [min]
    1.  wfrm M1
    2.  ∀inp.
            rmcorr M1 M1.q0 (λrs. rs min = inp ∧ ∀k. k ≠ min ⇒ rs k = 0) NONE
              (λrs. M1.Out = f inp)
    3.  M2.In = [min']
    4.  wfrm M2
    5.  ∀inp.
            rmcorr M2 M2.q0 (λrs. rs min' = inp ∧ ∀k. k ≠ min' ⇒ rs k = 0)
              NONE (λrs. M2.Out = g inp)
   ------------------------------------
        ∃min.
            (Cn M1 M2).In = [min] ∧ wfrm (Cn M1 M2) ∧
            ∀inp.
                rmcorr (Cn M1 M2) (Cn M1 M2).q0
                  (λrs. rs min = inp ∧ ∀k. k ≠ min ⇒ rs k = 0) NONE
                  (λrs. (Cn M1 M2).Out = f (g inp))
   
   : proof
> # > OK..
val it =
   Proof manager status: 6 proofs.
   6. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   5. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   4. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old f M1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old g M2 ⇒
            registerMachine$old8->correct1_rmcorr_V<-old (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  g.In = [gin]
         3.  f.In = [fin]
         4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
             (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧ rs (1 ⊗ fin) = N)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀r1 r2 r3 RS.
            RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
            Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
            rmcorr (dup r1 r2 r3) 0 P NONE Q
   : proofs
> # > OK..
val it =
   Proof manager status: 5 proofs.
   5. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   4. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   3. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old f M1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old g M2 ⇒
            registerMachine$old8->correct1_rmcorr_V<-old (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs[0m (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  g.In = [gin]
         3.  f.In = [fin]
         4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) ∧
             (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
             (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N ∧ rs (1 ⊗ fin) = N)
   : proofs
> # > OK..
val it =
   Proof manager status: 4 proofs.
   4. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   3. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   2. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old f M1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old g M2 ⇒
            registerMachine$old8->correct1_rmcorr_V<-old (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
            rmcorr g g.q0
              (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0
              (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
        
        Current goal:
         0.  wfrm g
         1.  wfrm f
         2.  LENGTH g.In = 1
         3.  LENGTH f.In = 1
         4.  rmcorr g g.q0
               (λrs. rs (HD g.In) = M ∧ ∀k. k ≠ HD g.In ⇒ rs k = 0) NONE
               (λrs. rs g.Out = N)
         5.  rmcorr f f.q0
               (λrs. rs (HD f.In) = N ∧ ∀k. k ≠ HD f.In ⇒ rs k = 0) NONE
               (λrs. rs f.Out = Op)
        ------------------------------------
             rmcorr (dup (2 ⊗ g.Out) (HD (MAP (λr. 1 ⊗ r) f.In)) (0 ⊗ 1)) 0
               (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ⇒ rs k = 0) NONE
               (λrs.
                    rs (HD (MAP (λr. 1 ⊗ r) f.In)) = N ∧
                    ∀k. k ≠ HD (MAP (λr. 1 ⊗ r) f.In) ∧ nfst k = 1 ⇒ rs k = 0)
   : proofs
> # > OK..
val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   2. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M1 M2 f g.
            wfrm M1 ∧ wfrm M2 ∧ LENGTH M1.In = 1 ∧ LENGTH M2.In = 1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old f M1 ∧
            registerMachine$old8->correct1_rmcorr_V<-old g M2 ⇒
            registerMachine$old8->correct1_rmcorr_V<-old (f ∘ g) (Cn M1 M2)
        
        Current goal:
         0.  wfrm M1
         1.  wfrm M2
         2.  LENGTH M1.In = 1
         3.  LENGTH M2.In = 1
         4.  ∀inp.
                 rmcorr M1 M1.q0
                   (λrs. HD M1.In = inp ∧ ∀k. k ≠ HD M1.In ⇒ rs k = 0) NONE
                   (λrs. M1.Out = f inp)
         5.  ∀inp.
                 rmcorr M2 M2.q0
                   (λrs. HD M2.In = inp ∧ ∀k. k ≠ HD M2.In ⇒ rs k = 0) NONE
                   (λrs. M2.Out = g inp)
         6.  ∀M N Op f.
                 wfrm f ∧ LENGTH f.In = 1 ∧
                 rmcorr M2 M2.q0 (λrs. rs (HD M2.In) = M) NONE
                   (λrs. rs M2.Out = N) ∧
                 rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE
                   (λrs. rs f.Out = Op) ⇒
                 rmcorr (Cn f M2) (Cn f M2).q0
                   (λrs. rs (HD (Cn f M2).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                   (λrs. rs (Cn f M2).Out = Op)
        ------------------------------------
             rmcorr (Cn M1 M2) (Cn M1 M2).q0
               (λrs.
                    HD (Cn M1 M2).In = inp ∧
                    ∀k. k ≠ HD (Cn M1 M2).In ⇒ rs k = 0) NONE
               (λrs. (Cn M1 M2).Out = f (g inp))
   : proofs
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   
   1. Completed goalstack:
        ⊢ wfrm g ∧ wfrm f ∧ LENGTH g.In = 1 ∧ LENGTH f.In = 1 ∧
          rmcorr g g.q0 (λrs. rs (HD g.In) = M) NONE (λrs. rs g.Out = N) ∧
          rmcorr f f.q0 (λrs. rs (HD f.In) = N) NONE (λrs. rs f.Out = Op) ⇒
          rmcorr (Cn f g) (Cn f g).q0
            (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
            (λrs. rs (Cn f g).Out = Op)
   : proofs
> # > OK..
val it =
   Proof manager status: 1 proof.
   1. Completed goalstack:
        ⊢ ∀RS.
              RS 2 = 0 ∧ RS 3 = 0 ∧ RS 4 = 0 ∧ RS 5 = 0 ⇒
              rmcorr exponential 14 (λrs. rs = RS) NONE
                (λrs.
                     rs 2 = RS 1 ** RS 0 ∧ rs 0 = 0 ∧
                     ∀k. k ∉ {0; 2} ⇒ rs k = RS k)
   : proofs
> # > OK..
val it = There are currently no proofs.: proofs
> > # # # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀r1 r2 r3 RS.
            RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
            Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
            rmcorr (dup r1 r2 r3) 0 P NONE Q
   : proofs
> > # # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃Q q2.
            rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME q2) Q ∧
            rmcorr (dup r1 r2 r3) q2 Q NONE
              (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> > # # # # # # poly: : error: <identifier> expected but ) was found
# # ;
poly: : error: Expression expected but ; was found
# ;
poly: : error: Expression expected but ; was found
# ;
poly: : error: Expression expected but ; was found
# ;
;poly: : error: Expression expected but ; was found
# 
# ;
poly: : error: Expression expected but ; was found
# Compilation interrupted

> > # OK..
2 subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)
          NONE (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME 1)
          (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # # # OK..

Goal proved.
⊢ rmcorr (dup r1 r2 r3) 0 (λrs. rs = RS) (SOME 1)
    (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)

Remaining subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)
          NONE (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃Q q2.
            rmcorr (dup r1 r2 r3) 1
              (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k) (SOME q2) Q ∧
            rmcorr (dup r1 r2 r3) q2 Q NONE
              (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> > # OK..

Exception raised at Tactical.Q_TAC:
No parse for quotation
Exception-
   HOL_ERR
     {message = "No parse for quotation", origin_function = "Q_TAC",
      origin_structure = "Tactical"} raised
> > # OK..

Exception raised at Tactical.Q_TAC:
No parse for quotation
Exception-
   HOL_ERR
     {message = "No parse for quotation", origin_function = "Q_TAC",
      origin_structure = "Tactical"} raised
> > # OK..

Exception raised at Tactical.Q_TAC:
No parse for quotation
Exception-
   HOL_ERR
     {message = "No parse for quotation", origin_function = "Q_TAC",
      origin_structure = "Tactical"} raised
> > # OK..

Exception raised at Tactical.Q_TAC:
No parse for quotation
Exception-
   HOL_ERR
     {message = "No parse for quotation", origin_function = "Q_TAC",
      origin_structure = "Tactical"} raised
> > # OK..
2 subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 4
          (λrs.
               rs r1 = 0 ∧ rs r2 = N ∧ rs r3 = N ∧
               ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) NONE
          (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)
          (SOME 4)
          (λrs.
               rs r1 = 0 ∧ rs r2 = N ∧ rs r3 = N ∧
               ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k)

2 subgoals
   : proof
> # > val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃Q q2.
            rmcorr (dup r1 r2 r3) 1
              (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k) (SOME q2) Q ∧
            rmcorr (dup r1 r2 r3) q2 Q NONE
              (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> # > val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)
          NONE (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> > # OK..

Exception raised at Q.EXISTS_TAC:
goal not an exists
Exception-
   HOL_ERR
     {message = "goal not an exists", origin_function = "EXISTS_TAC",
      origin_structure = "Q"} raised
> # > val it =
   Initial goal:
   
   ∀r1 r2 r3 RS.
       RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
       Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
       rmcorr (dup r1 r2 r3) 0 P NONE Q: proof
> > # # # # # # # # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃Q q2.
            rmcorr (dup r1 r2 r3) 1
              (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k) (SOME q2) Q ∧
            rmcorr (dup r1 r2 r3) q2 Q NONE
              (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 4
          (λrs.
               rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
               ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) NONE
          (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)
          (SOME 4)
          (λrs.
               rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
               ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k)

2 subgoals
   : proof
> > # # # # # # # # OK..

Goal proved.
 [....]
⊢ rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)
    (SOME 4)
    (λrs.
         rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
         ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k)

Remaining subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 4
          (λrs.
               rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
               ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) NONE
          (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        ∃INV.
            (∀rs.
                 rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
                 (∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) ⇒
                 INV rs) ∧
            (∀rs.
                 INV rs ∧ rs r3 = 0 ⇒
                 ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ∧
            ∀N.
                rmcorr (dup r1 r2 r3) 5
                  (λrs. INV rs⦇r3 ↦ rs r3 + 1⦈ ∧ rs r3 = N) (SOME 4)
                  (λrs'. INV rs' ∧ rs' r3 ≤ N)
   
   : proof
> > # OK..
Don't expect to find a ) in this position after a <beginning of input>
at line 1725, character 102 and in compiler-generated text.

Exception raised at Absyn.Absyn:
in compiler-generated text:
Don't expect to find a ) in this position after a <beginning of input>
at line 1725, character 102 and in compiler-generated text.

Exception-
   HOL_ERR
     {message =
      "in compiler-generated text:\nDon't expect to find a ) in this position after a <beginning of input>\nat line 1725, character 102 and in compiler-generated text.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> > # OK..
Don't expect to find a ) in this position after a <beginning of input>
at line 1725, character 102 and in compiler-generated text.

Exception raised at Absyn.Absyn:
in compiler-generated text:
Don't expect to find a ) in this position after a <beginning of input>
at line 1725, character 102 and in compiler-generated text.

Exception-
   HOL_ERR
     {message =
      "in compiler-generated text:\nDon't expect to find a ) in this position after a <beginning of input>\nat line 1725, character 102 and in compiler-generated text.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> > # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        (∀rs.
             rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
             (∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) ⇒
             (λrs.
                  rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
                  ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k) rs) ∧
        (∀rs.
             (λrs.
                  rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
                  ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k) rs ∧ rs r3 = 0 ⇒
             ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ∧
        ∀N.
            rmcorr (dup r1 r2 r3) 5
              (λrs.
                   (λrs.
                        rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
                        ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k)
                     rs⦇r3 ↦ rs r3 + 1⦈ ∧ rs r3 = N) (SOME 4)
              (λrs'.
                   (λrs.
                        rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
                        ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k) rs' ∧ rs' r3 ≤ N)
   
   : proof
> > # # # # # OK..

Exception raised at Tactic.MATCH_MP_TAC:
No match
Exception-
   HOL_ERR
     {message = "No match", origin_function = "MATCH_MP_TAC",
      origin_structure = "Tactic"} raised
> > # # OK..
2 subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 5
          (λrs.
               (rs r1 + (rs r3 + 1) = RS r1 ∧ rs r2 = RS r1 ∧
                ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) ∧ rs r3 = N)
          (SOME 4)
          (λrs'.
               (rs' r1 + rs' r3 = RS r1 ∧ rs' r2 = RS r1 ∧
                ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs' k = RS k) ∧ rs' r3 ≤ N)
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
    4.  rs r1 = RS r1
    5.  rs r2 = RS r1
    6.  ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k
    7.  rs r3 = 0
    8.  k ≠ r2
   ------------------------------------
        rs k = RS k

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
    4.  rs r1 = RS r1
    5.  rs r2 = RS r1
    6.  ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k
    7.  rs r3 = 0
    8.  k ≠ r2
    9.  k ≠ r1
   ------------------------------------
        rs k = RS k
   
   : proof
> > # OK..

Goal proved.
 [..........] ⊢ rs k = RS k

Goal proved.
 [.........] ⊢ rs k = RS k

Remaining subgoals:
val it =
   
    0.  RS r3 = 0
    1.  r1 ≠ r2
    2.  r1 ≠ r3
    3.  r2 ≠ r3
   ------------------------------------
        rmcorr (dup r1 r2 r3) 5
          (λrs.
               (rs r1 + (rs r3 + 1) = RS r1 ∧ rs r2 = RS r1 ∧
                ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) ∧ rs r3 = N)
          (SOME 4)
          (λrs'.
               (rs' r1 + rs' r3 = RS r1 ∧ rs' r2 = RS r1 ∧
                ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs' k = RS k) ∧ rs' r3 ≤ N)
   
   : proof
> > # # # OK..

Goal proved.
 [..]
⊢ rmcorr (dup r1 r2 r3) 5
    (λrs.
         (rs r1 + (rs r3 + 1) = RS r1 ∧ rs r2 = RS r1 ∧
          ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) ∧ rs r3 = N) (SOME 4)
    (λrs'.
         (rs' r1 + rs' r3 = RS r1 ∧ rs' r2 = RS r1 ∧
          ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs' k = RS k) ∧ rs' r3 ≤ N)

Goal proved.
 [....]
⊢ (∀rs.
       rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
       (∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) ⇒
       (λrs.
            rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
            ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k) rs) ∧
  (∀rs.
       (λrs.
            rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
            ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k) rs ∧ rs r3 = 0 ⇒
       ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ∧
  ∀N.
      rmcorr (dup r1 r2 r3) 5
        (λrs.
             (λrs.
                  rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
                  ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k) rs⦇r3 ↦ rs r3 + 1⦈ ∧
             rs r3 = N) (SOME 4)
        (λrs'.
             (λrs.
                  rs r1 + rs r3 = RS r1 ∧ rs r2 = RS r1 ∧
                  ∀k. k ∉ {r1; r2; r3} ⇒ rs k = RS k) rs' ∧ rs' r3 ≤ N)

Goal proved.
 [....]
⊢ ∃INV.
      (∀rs.
           rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
           (∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) ⇒
           INV rs) ∧
      (∀rs. INV rs ∧ rs r3 = 0 ⇒ ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ∧
      ∀N.
          rmcorr (dup r1 r2 r3) 5 (λrs. INV rs⦇r3 ↦ rs r3 + 1⦈ ∧ rs r3 = N)
            (SOME 4) (λrs'. INV rs' ∧ rs' r3 ≤ N)

Goal proved.
 [....]
⊢ rmcorr (dup r1 r2 r3) 4
    (λrs.
         rs r1 = 0 ∧ rs r2 = RS r1 ∧ rs r3 = RS r1 ∧
         ∀k. k ≠ r1 ∧ k ≠ r2 ∧ k ≠ r3 ⇒ rs k = RS k) NONE
    (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)

Goal proved.
 [....]
⊢ ∃Q q2.
      rmcorr (dup r1 r2 r3) 1 (λrs. rs r2 = 0 ∧ ∀k. k ≠ r2 ⇒ rs k = RS k)
        (SOME q2) Q ∧
      rmcorr (dup r1 r2 r3) q2 Q NONE
        (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1)
val it =
   Initial goal proved.
   ⊢ ∀r1 r2 r3 RS.
         RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
         Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
         rmcorr (dup r1 r2 r3) 0 P NONE Q: proof
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # val dup_correct_V =
   ⊢ ∀r1 r2 r3 RS.
         RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
         Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
         rmcorr (dup r1 r2 r3) 0 P NONE Q: thm
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
Proof of 

∀M N Op f g.
    wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
    rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
    rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
    rmcorr (Cn f g) (Cn f g).q0 (λrs. rs (HD (Cn f g).In) = M) NONE
      (λrs. rs (Cn f g).Out = Op)

failed.
Failed to prove theorem Cn_rmcorr.

Exception raised at Tactical.THEN1:
first subgoal not solved by second tactic (THEN1 on line 2646) (THEN1 on line 2647) (THEN1 on line 2637) (THEN1 on line 2652) (THEN1 on line 2653) (THEN1 on line 2660)
Exception-
   HOL_ERR
     {message =
      "first subgoal not solved by second tactic (THEN1 on line 2646) (THEN1 on line 2647) (THEN1 on line 2637) (THEN1 on line 2652) (THEN1 on line 2653) (THEN1 on line 2660)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
Proof of 

∀M N Op f g.
    wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
    rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
    rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
    rmcorr (Cn f g) (Cn f g).q0 (λrs. rs (HD (Cn f g).In) = M) NONE
      (λrs. rs (Cn f g).Out = Op)

failed.
Failed to prove theorem Cn_rmcorr.

Exception raised at Tactic.MATCH_MP_TAC:
No match (THEN1 on line 2656)
Exception-
   HOL_ERR
     {message = "No match (THEN1 on line 2656)", origin_function =
      "MATCH_MP_TAC", origin_structure = "Tactic"} raised
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
Proof of 

∀M N Op f g.
    wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
    rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
    rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
    rmcorr (Cn f g) (Cn f g).q0 (λrs. rs (HD (Cn f g).In) = M) NONE
      (λrs. rs (Cn f g).Out = Op)

failed.
Failed to prove theorem Cn_rmcorr.

Exception raised at Tactic.MATCH_MP_TAC:
No match (THEN1 on line 2656)
Exception-
   HOL_ERR
     {message = "No match (THEN1 on line 2656)", origin_function =
      "MATCH_MP_TAC", origin_structure = "Tactic"} raised
> > > > # # # # # # # # # val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0 (λrs. rs (HD (Cn f g).In) = M) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#

Exception raised at Tactic.MATCH_MP_TAC:
No match (THEN1 on line 2656)
Exception-
   HOL_ERR
     {message = "No match (THEN1 on line 2656)", origin_function =
      "MATCH_MP_TAC", origin_structure = "Tactic"} raised
> # > val it =
   Initial goal:
   
   ∀M N Op f g.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0 (λrs. rs (HD (Cn f g).In) = M) NONE
         (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#

Exception raised at Tactic.MATCH_MP_TAC:
No match
Exception-
   HOL_ERR
     {message = "No match", origin_function = "MATCH_MP_TAC",
      origin_structure = "Tactic"} raised
> > # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M) NONE (λrs. rs (1 ⊗ fin) = N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE (λrs. rs (1 ⊗ fin) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        DISJOINT {0 ⊗ x | x ∈ g.Q}
          {1 ⊗ x | x = 0 ∨ x = 1 ∨ x = 2 ∨ x = 3 ∨ x = 4 ∨ x = 5}

2 subgoals
   : proof
> > # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#

Goal proved.
 [......]
⊢ DISJOINT {0 ⊗ x | x ∈ g.Q}
    {1 ⊗ x | x = 0 ∨ x = 1 ∨ x = 2 ∨ x = 3 ∨ x = 4 ∨ x = 5}

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE (λrs. rs (1 ⊗ fin) = N)
   
   : proof
> > # # # # # # # # # # # # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # # OK..
3 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        g.q0 ∈ g.Q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        NONE = npair_opt 0 NONE

3 subgoals
   : proof
> > # OK..

Goal proved.
⊢ NONE = npair_opt 0 NONE

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        g.q0 ∈ g.Q

2 subgoals
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#

Goal proved.
 [......] ⊢ g.q0 ∈ g.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = MAP (λr. 2 ⊗ r) g.In
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # # OK..
metis: r[+0+12]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = MAP (λr. 2 ⊗ r) g.In
    7.  mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = MAP (λr. 2 ⊗ r) g.In
    7.  mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # OK..

Exception raised at Tactic.MATCH_MP_TAC:
No match
Exception-
   HOL_ERR
     {message = "No match", origin_function = "MATCH_MP_TAC",
      origin_structure = "Tactic"} raised
> mrInst_correct_kN;
val it =
   ⊢ nfst k ≠ n ∧ wfrm M ∧ q ∈ M.Q ∧ P' = liftP_V n P (λrs. rs k = N) ∧
     Q' = liftP_V n Q (λrs. rs k = N) ⇒
     rmcorr M q P opt Q ⇒
     rmcorr (mrInst n M) q P' opt Q': thm
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = MAP (λr. 2 ⊗ r) g.In
    7.  mrInst 2 g with In := MAP (λr. 2 ⊗ r) g.In =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = MAP (λr. 2 ⊗ r) g.In
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # # OK..
metis: r[+0+12]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        rmcorr (mrInst 2 g with In := [2 ⊗ gin]) g.q0 (λrs. rs (2 ⊗ gin) = M)
          NONE (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        rmcorr (mrInst 2 g) g.q0 (λrs. rs (2 ⊗ gin) = M) NONE
          (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N)
   
   : proof
> > # # # # # OK..
metis: r[+0+16]#
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        ∃N' P Q k.
            nfst k ≠ 2 ∧
            (λrs. rs (2 ⊗ gin) = M) = liftP_V 2 P (λrs. rs k = N') ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. rs k = N') ∧ rmcorr g g.q0 P NONE Q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        g.q0 ∈ g.Q

2 subgoals
   : proof
> > # OK..

Goal proved.
 [.] ⊢ g.q0 ∈ g.Q

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        ∃N' P Q k.
            nfst k ≠ 2 ∧
            (λrs. rs (2 ⊗ gin) = M) = liftP_V 2 P (λrs. rs k = N') ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. rs k = N') ∧ rmcorr g g.q0 P NONE Q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        nfst (0 ⊗ 1) ≠ 2 ∧
        (λrs. rs (2 ⊗ gin) = M) =
        liftP_V 2 (λrs. rs gin = M) (λrs. rs (0 ⊗ 1) = 0) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N) (λrs. rs (0 ⊗ 1) = 0) ∧
        rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        (λrs. rs (2 ⊗ g.Out) = N ∧ rs (0 ⊗ 1) = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        (λrs. rs (2 ⊗ gin) = M) = (λrs. rs (2 ⊗ gin) = M ∧ rs (0 ⊗ 1) = 0)

2 subgoals
   : proof
> > # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        nfst (0 ⊗ 1) ≠ 2 ∧
        (λrs. rs (2 ⊗ gin) = M) =
        liftP_V 2 (λrs. rs gin = M) (λrs. rs (0 ⊗ 1) = 0) ∧
        (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
        liftP_V 2 (λrs. rs g.Out = N) (λrs. rs (0 ⊗ 1) = 0) ∧
        rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op)
    6.  (mrInst 2 g).In = [2 ⊗ gin]
    7.  mrInst 2 g with In := [2 ⊗ gin] =
        mrInst 2 g with In := (mrInst 2 g).In
   ------------------------------------
        ∃N' P Q k.
            nfst k ≠ 2 ∧
            (λrs. rs (2 ⊗ gin) = M) = liftP_V 2 P (λrs. rs k = N') ∧
            (λrs. rs (0 ⊗ 1) = 0 ∧ rs (2 ⊗ g.Out) = N) =
            liftP_V 2 Q (λrs. rs k = N') ∧ rmcorr g g.q0 P NONE Q
   
   : proof
> # > OK..
val it =
   Proof manager status: 1 proof.
   1. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   : proofs
> > # # # # # # # # # val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
metis: r[+0+16]#
val it =
   Initial goal proved.
   ⊢ ∀M N Op f g.
         wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
         rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
         rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
         rmcorr (Cn f g) (Cn f g).q0
           (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
           (λrs. rs (Cn f g).Out = Op): proof
> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+12]#
metis: r[+0+16]#
val Cn_rmcorr =
   ⊢ ∀M N Op f g.
         wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
         rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
         rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
         rmcorr (Cn f g) (Cn f g).q0
           (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
           (λrs. rs (Cn f g).Out = Op): thm
> > > > # # # # # # # # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   2. Completed goalstack:
        ⊢ ∀M N Op f g.
              wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
              rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
              rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
              rmcorr (Cn f g) (Cn f g).q0
                (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                (λrs. rs (Cn f g).Out = Op)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
          NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
          NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        NONE = npair_opt 1 NONE

2 subgoals
   : proof
> > # OK..

Goal proved.
⊢ NONE = npair_opt 1 NONE

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
          NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃RS.
            (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0) =
            (λrs. rs = RS) ∧
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 ∀k.
                     k ≠ 1 ⊗ fin ⇒
                     rs k = RS k ∧ rs (1 ⊗ fin) = RS (2 ⊗ g.Out)) ∧
            RS (0 ⊗ 1) = 0
   
   : proof
> > # OK..
Don't expect to find a <end of input> in this position after a if
in compiler-generated text and on line 2699, characters 49-50.

Exception raised at Absyn.Absyn:
on line 2699, characters 49-50:
Don't expect to find a <end of input> in this position after a if
in compiler-generated text and on line 2699, characters 49-50.

Exception-
   HOL_ERR
     {message =
      "on line 2699, characters 49-50:\nDon't expect to find a <end of input> in this position after a if\nin compiler-generated text and on line 2699, characters 49-50.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1)) 0
          (λrs. rs (2 ⊗ g.Out) = N ∧ ∀k. nfst k = 1 ∨ k = 0 ⊗ 1 ⇒ rs k = 0)
          NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> dup_correct_V;
val it =
   ⊢ ∀r1 r2 r3 RS.
         RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
         Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
         rmcorr (dup r1 r2 r3) 0 P NONE Q: thm
> rmcorr_def;
val it =
   ⊢ ∀M q P qf Q.
         rmcorr M q P qf Q ⇔
         ∀rs. P rs ⇒ ∃n rs'. run_step M (rs,SOME q) n = (rs',qf) ∧ Q rs': thm
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # OK..
3 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        DISJOINT {1 ⊗ x | x = 0 ∨ x = 1 ∨ x = 2 ∨ x = 3 ∨ x = 4 ∨ x = 5}
          {2 ⊗ x | x ∈ f.Q}
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        DISJOINT {0 ⊗ x | x ∈ g.Q} {2 ⊗ x | x ∈ f.Q}

3 subgoals
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        DISJOINT {1 ⊗ x | x = 0 ∨ x = 1 ∨ x = 2 ∨ x = 3 ∨ x = 4 ∨ x = 5}
          {2 ⊗ x | x ∈ f.Q}

2 subgoals
   : proof
> > # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#

Goal proved.
 [......]
⊢ DISJOINT {1 ⊗ x | x = 0 ∨ x = 1 ∨ x = 2 ∨ x = 3 ∨ x = 4 ∨ x = 5}
    {2 ⊗ x | x ∈ f.Q}

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃P Q.
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            liftP 1 P ∧ (λrs. rs (1 ⊗ f.Out) = Op) = liftP 1 Q ∧
            rmcorr f f.q0 P NONE Q
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE
              (λrs.
                   rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   1. Completed goalstack:
        ⊢ ∀M N Op f g.
              wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
              rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
              rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
              rmcorr (Cn f g) (Cn f g).q0
                (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # val it =
   Proof manager status: 3 proofs.
   3. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   2. Completed goalstack:
        ⊢ ∀M N Op f g.
              wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
              rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
              rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
              rmcorr (Cn f g) (Cn f g).q0
                (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                (λrs. rs (Cn f g).Out = Op)
   
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin RS.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N ∧ rs = RS) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> # > OK..
val it =
   Proof manager status: 2 proofs.
   2. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   
   1. Completed goalstack:
        ⊢ ∀M N Op f g.
              wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
              rmcorr g g.q0 (λrs. rs gin = M) NONE (λrs. rs g.Out = N) ∧
              rmcorr f f.q0 (λrs. rs fin = N) NONE (λrs. rs f.Out = Op) ⇒
              rmcorr (Cn f g) (Cn f g).q0
                (λrs. rs (HD (Cn f g).In) = M ∧ rs (0 ⊗ 1) = 0) NONE
                (λrs. rs (Cn f g).Out = Op)
   : proofs
> # > OK..
val it =
   Proof manager status: 1 proof.
   1. Completed goalstack:
        ⊢ ∀r1 r2 r3 RS.
              RS r3 = 0 ∧ r1 ≠ r2 ∧ r1 ≠ r3 ∧ r2 ≠ r3 ∧ P = (λrs. rs = RS) ∧
              Q = (λrs. ∀k. k ≠ r2 ⇒ rs k = RS k ∧ rs r2 = RS r1) ⇒
              rmcorr (dup r1 r2 r3) 0 P NONE Q
   : proofs
> # > OK..
val it = There are currently no proofs.: proofs
> > # # # # # # # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin RS.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N ∧ rs = RS) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # # # # # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#

Goal proved.
 [......]
⊢ rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
    (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) NONE
    (λrs. rs (1 ⊗ f.Out) = Op)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE
              (λrs.
                   rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) ∧
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃RS'.
            (λrs.
                 rs (2 ⊗ g.Out) = N ∧
                 ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) =
            (λrs. rs = RS') ∧
            (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
            (λrs.
                 ∀k.
                     k ≠ 1 ⊗ fin ⇒
                     rs k = RS' k ∧ rs (1 ⊗ fin) = RS' (2 ⊗ g.Out)) ∧
            RS' (0 ⊗ 1) = 0
   
   : proof
> > # OK..
Don't expect to find a else in this position after a if
on line 2701, characters 71-74 and on line 2701, characters 49-50.

Exception raised at Absyn.Absyn:
on line 2701, characters 49-50:
Don't expect to find a else in this position after a if
on line 2701, characters 71-74 and on line 2701, characters 49-50.

Exception-
   HOL_ERR
     {message =
      "on line 2701, characters 49-50:\nDon't expect to find a else in this position after a if\non line 2701, characters 71-74 and on line 2701, characters 49-50.\n",
      origin_function = "Absyn", origin_structure = "Absyn"} raised
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) =
        (λrs.
             rs =
             (λr.
                  if r = 2 ⊗ g.Out then N
                  else if nfst r ≠ 2 then 0
                  else RS (nsnd r))) ∧
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             ∀k.
                 k ≠ 1 ⊗ fin ⇒
                 rs k =
                 (λr.
                      if r = 2 ⊗ g.Out then N
                      else if nfst r ≠ 2 then 0
                      else RS (nsnd r)) k ∧
                 rs (1 ⊗ fin) =
                 (λr.
                      if r = 2 ⊗ g.Out then N
                      else if nfst r ≠ 2 then 0
                      else RS (nsnd r)) (2 ⊗ g.Out)) ∧
        (λr.
             if r = 2 ⊗ g.Out then N
             else if nfst r ≠ 2 then 0
             else RS (nsnd r)) (0 ⊗ 1) =
        0
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             ∀k.
                 k ≠ 1 ⊗ fin ⇒
                 rs k =
                 (if k = 2 ⊗ g.Out then N
                  else if nfst k ≠ 2 then 0
                  else RS (nsnd k)) ∧ rs (1 ⊗ fin) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) =
        (λrs.
             rs =
             (λr.
                  if r = 2 ⊗ g.Out then N
                  else if nfst r ≠ 2 then 0
                  else RS (nsnd r)))

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rs (2 ⊗ g.Out) = N ∧
        (∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) ⇔
        ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rs (2 ⊗ g.Out) = N ∧
        (∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) ⇔
        ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rs (2 ⊗ g.Out) = N ∧
        (∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) ⇔
        ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rs (2 ⊗ g.Out) = N ∧
        (∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) ⇔
        ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   
   : proof
> > # OK..
3 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k ≠ 2
   ------------------------------------
        (if q = g.Out then N else RS q) = RS q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k ≠ 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else 0) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)

3 subgoals
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  r ≠ 2 ⊗ g.Out
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  r = 2 ⊗ g.Out
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)

2 subgoals
   : proof
> > # OK..

Goal proved.
 [........]
⊢ rs r =
  if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
  else if nfst r ≠ 2 then 0
  else RS (nsnd r)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  r ≠ 2 ⊗ g.Out
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  r ≠ 2 ⊗ g.Out
    8.  nfst r = 2
   ------------------------------------
        rs r = RS (nsnd r)
   
   : proof
> > # OK..
metis: r[+0+6]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> > # OK..

Exception raised at Tactical.FIRST_ASSUM:

Exception-
   HOL_ERR
     {message = "", origin_function = "FIRST_ASSUM", origin_structure =
      "Tactical"} raised
> DB.match"_ /\ _";
val it = (): unit
> poly: : error: unexpected character _ in \ ... \
# poly: : error: no matching quote found on this line
Static Errors
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2707
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2707",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> find"AND";
val it =
   [(("ConseqConv", "AND_CLAUSES_FX"), (⊢ ∀t. F ∧ t ⇔ F, Thm)),
    (("ConseqConv", "AND_CLAUSES_TX"), (⊢ ∀t. T ∧ t ⇔ t, Thm)),
    (("ConseqConv", "AND_CLAUSES_XF"), (⊢ ∀t. t ∧ F ⇔ F, Thm)),
    (("ConseqConv", "AND_CLAUSES_XT"), (⊢ ∀t. t ∧ T ⇔ t, Thm)),
    (("ConseqConv", "AND_CLAUSES_XX"), (⊢ ∀t. t ∧ t ⇔ t, Thm)),
    (("arithmetic", "EVEN_AND_ODD"), (⊢ ∀n. ¬(EVEN n ∧ ODD n), Thm)),
    (("bool", "AND1_THM"), (⊢ ∀t1 t2. t1 ∧ t2 ⇒ t1, Thm)),
    (("bool", "AND2_THM"), (⊢ ∀t1 t2. t1 ∧ t2 ⇒ t2, Thm)),
    (("bool", "AND_CLAUSES"),
     (⊢ ∀t.
            (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧
            (t ∧ t ⇔ t), Thm)),
    (("bool", "AND_CONG"),
     (⊢ ∀P P' Q Q'. (Q ⇒ (P ⇔ P')) ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q'),
      Thm)),
    (("bool", "AND_DEF"), (⊢ $/\ = (λt1 t2. ∀t. (t1 ⇒ t2 ⇒ t) ⇒ t), Def)),
    (("bool", "AND_IMP_INTRO"),
     (⊢ ∀t1 t2 t3. t1 ⇒ t2 ⇒ t3 ⇔ t1 ∧ t2 ⇒ t3, Thm)),
    (("bool", "AND_INTRO_THM"), (⊢ ∀t1 t2. t1 ⇒ t2 ⇒ t1 ∧ t2, Thm)),
    (("bool", "BOTH_EXISTS_AND_THM"),
     (⊢ ∀P Q. (∃x. P ∧ Q) ⇔ (∃x. P) ∧ ∃x. Q, Thm)),
    (("bool", "COND_EXPAND"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ (¬b ∨ t1) ∧ (b ∨ t2), Thm)),
    (("bool", "COND_EXPAND_IMP"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ (b ⇒ t1) ∧ (¬b ⇒ t2), Thm)),
    (("bool", "COND_EXPAND_OR"),
     (⊢ ∀b t1 t2. (if b then t1 else t2) ⇔ b ∧ t1 ∨ ¬b ∧ t2, Thm)),
    (("bool", "COND_RAND"),
     (⊢ ∀f b x y. f (if b then x else y) = if b then f x else f y, Thm)),
    (("bool", "EQ_EXPAND"), (⊢ ∀t1 t2. (t1 ⇔ t2) ⇔ t1 ∧ t2 ∨ ¬t1 ∧ ¬t2, Thm)),
    (("bool", "FORALL_AND_THM"),
     (⊢ ∀P Q. (∀x. P x ∧ Q x) ⇔ (∀x. P x) ∧ ∀x. Q x, Thm)),
    (("bool", "LEFT_AND_CONG"),
     (⊢ ∀P P' Q Q'. (P ⇔ P') ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q'), Thm)),
    (("bool", "LEFT_AND_FORALL_THM"),
     (⊢ ∀P Q. (∀x. P x) ∧ Q ⇔ ∀x. P x ∧ Q, Thm)),
    (("bool", "LEFT_AND_OVER_OR"),
     (⊢ ∀A B C. A ∧ (B ∨ C) ⇔ A ∧ B ∨ A ∧ C, Thm)),
    (("bool", "LEFT_EXISTS_AND_THM"),
     (⊢ ∀P Q. (∃x. P x ∧ Q) ⇔ (∃x. P x) ∧ Q, Thm)),
    (("bool", "LEFT_OR_OVER_AND"),
     (⊢ ∀A B C. A ∨ B ∧ C ⇔ (A ∨ B) ∧ (A ∨ C), Thm)),
    (("bool", "LET_RAND"),
     (⊢ P (let x = M in N x) ⇔ (let x = M in P (N x)), Thm)),
    (("bool", "literal_case_RAND"),
     (⊢ P (case M of x => N x) = case M of x => P (N x), Thm)),
    (("bool", "MONO_AND"), (⊢ (x ⇒ y) ∧ (z ⇒ w) ⇒ x ∧ z ⇒ y ∧ w, Thm)),
    (("bool", "NOT_AND"), (⊢ ¬(t ∧ ¬t), Thm)),
    (("bool", "RIGHT_AND_FORALL_THM"),
     (⊢ ∀P Q. P ∧ (∀xCompilation interrupted

> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2707
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2707",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> val it = (): unit
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   10.  ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   10.  ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2707
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2707",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> val it = (): unit
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   10.  ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q

2 subgoals
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = 2 ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> AND2_THM;
val it = ⊢ ∀t1 t2. t1 ∧ t2 ⇒ t2: thm
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
   ------------------------------------
        rs (2 ⊗ q') = RS q'
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = 2 ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> DB.match``_ ∧ !_. _``;
val it = (): unit
> poly: : error: Type error in function application.
   Function: DB.match : string list -> term -> data list
   Argument: (Parse.Term [QUOTE " (*#loc 4 11*)_ \226\136\167 !_. _"]) : term
   Reason:
      Can't unify string list (*In Basis*) with
         term (*Created from opaque signature*) (Different type constructors)
Found near DB.match (Parse.Term [QUOTE " (*#loc 4 11*)_ \226\136\167 !_. _"])
Static Errors
> DB.match``_ ∧ ! _``;
val it = (): unit
> poly: : error: Type error in function application.
   Function: DB.match : string list -> term -> data list
   Argument: (Parse.Term [QUOTE " (*#loc 2 11*)_ \226\136\167 ! _"]) : term
   Reason:
      Can't unify string list (*In Basis*) with
         term (*Created from opaque signature*) (Different type constructors)
Found near DB.match (Parse.Term [QUOTE " (*#loc 2 11*)_ \226\136\167 ! _"])
Static Errors
> DB.match``_ ∧ !. _``;
val it = (): unit
> poly: : error: Type error in function application.
   Function: DB.match : string list -> term -> data list
   Argument: (Parse.Term [QUOTE " (*#loc 2 11*)_ \226\136\167 !. _"]) : term
   Reason:
      Can't unify string list (*In Basis*) with
         term (*Created from opaque signature*) (Different type constructors)
Found near DB.match (Parse.Term [QUOTE " (*#loc 2 11*)_ \226\136\167 !. _"])
Static Errors
> DB.match``_ ∧ !_. _``;
val it = (): unit
> poly: : error: Type error in function application.
   Function: DB.match : string list -> term -> data list
   Argument: (Parse.Term [QUOTE " (*#loc 2 11*)_ \226\136\167 !_. _"]) : term
   Reason:
      Can't unify string list (*In Basis*) with
         term (*Created from opaque signature*) (Different type constructors)
Found near DB.match (Parse.Term [QUOTE " (*#loc 2 11*)_ \226\136\167 !_. _"])
Static Errors
> ADD2_THM;
poly: : error: Value or constructor (ADD2_THM) has not been declared Found near ADD2_THM
Static Errors
> AND2_THM;
val it = ⊢ ∀t1 t2. t1 ∧ t2 ⇒ t2: thm
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2707
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2707",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..
metis: r[+0+18]+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+3#
r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   10.  ∀k.
            nfst k ≠ 2 ⇒
            rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q ⇒ ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+0+0+0+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   10.  ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        ∀q. rs (2 ⊗ q) = RS q

2 subgoals
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  r ≠ 2 ⊗ g.Out
    8.  nfst r = 2
   ------------------------------------
        rs r = RS (nsnd r)
   
   : proof
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  r ≠ 2 ⊗ g.Out
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin RS.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N ∧ rs = RS) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # # # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             ∀k.
                 k ≠ 1 ⊗ fin ⇒
                 rs k =
                 (if k = 2 ⊗ g.Out then N
                  else if nfst k ≠ 2 then 0
                  else RS (nsnd k)) ∧ rs (1 ⊗ fin) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q) =
        (λrs.
             rs =
             (λr.
                  if r = 2 ⊗ g.Out then N
                  else if nfst r ≠ 2 then 0
                  else RS (nsnd r)))

2 subgoals
   : proof
> > # OK..
3 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k ≠ 2
   ------------------------------------
        (if q = g.Out then N else RS q) = RS q
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k ≠ 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else 0) = 0
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)

3 subgoals
   : proof
> > # # # OK..
metis: r[+0+6]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
   : proof
> Cannot find file g.ui
error in load g : Fail "Cannot find file g.ui"
Exception- Fail "Cannot find file g.ui" raised
> > # # poly: : error: unknown character "\226"
poly: : error: unknown character "\136"
poly: : error: unknown character "\128"
poly: : error: invalid identifier - g.)
Static Errors
> > # poly: : error: Type error in function application.
   Function: e : tactic -> proof
   Argument: () : unit
   Reason:
      Can't unify goal -> goal list * validation to {} (Incompatible types)
Found near e ()
Static Errors
> > # OK..
metis: r[+0+18]+0+0+0+0+0+0+0+0+0+0+0+0+0+1+0+3#
r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   10.  ∀k.
            nfst k ≠ 2 ⇒
            rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q ⇒ ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+0+0+0+0!

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2708
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2708",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> DB.match``==>``;
val it = (): unit
> poly: : error: Type error in function application.
   Function: DB.match : string list -> term -> data list
   Argument: (Parse.Term [QUOTE " (*#loc 2710 11*)==>"]) : term
   Reason:
      Can't unify string list (*In Basis*) with
         term (*Created from opaque signature*) (Different type constructors)
Found near DB.match (Parse.Term [QUOTE " (*#loc 2710 11*)==>"])
Static Errors
> DB.match``_ ==> _``;
val it = (): unit
> poly: : error: Type error in function application.
   Function: DB.match : string list -> term -> data list
   Argument: (Parse.Term [QUOTE " (*#loc 2 11*)_ ==> _"]) : term
   Reason:
      Can't unify string list (*In Basis*) with
         term (*Created from opaque signature*) (Different type constructors)
Found near DB.match (Parse.Term [QUOTE " (*#loc 2 11*)_ ==> _"])
Static Errors
> # > val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. nfst k ≠ 2 ⇒ rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q
    7.  q ≠ g.Out
    8.  p = 2
    9.  r = p ⊗ q
   10.  ∀k.
            nfst k ≠ 2 ⇒
            rs k = 0 ∧ ∀q. rs (2 ⊗ q) = RS q ⇒ ∀q. rs (2 ⊗ q) = RS q
   ------------------------------------
        rs (2 ⊗ q) = RS q
   
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+0+0+0+0!

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2707
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2707",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+1+0+2+0+0+0+0!

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2707
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2707",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin RS.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N ∧ rs = RS) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0) Q
              NONE
              (λrs.
                   rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) ∧
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (msInst 0 (mrInst 2 g) with In := MAP (λr. 2 ⊗ r) g.In).Out =
               N ∧ ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k))
          NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k))
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # # # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             ∀k.
                 k ≠ 1 ⊗ fin ⇒
                 rs k =
                 (if k = 2 ⊗ g.Out then N
                  else if nfst k ≠ 2 then 0
                  else RS (nsnd k)) ∧ rs (1 ⊗ fin) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) =
        (λrs.
             rs =
             (λr.
                  if r = 2 ⊗ g.Out then N
                  else if nfst r ≠ 2 then 0
                  else RS (nsnd r)))

2 subgoals
   : proof
> > # poly: : error: Value or constructor (w) has not been declared
Found near e (w [FUN_EQ_THM] >> rw [EQ_IMP_THM])
Static Errors
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rs (2 ⊗ g.Out) = N ∧
        (∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) ⇔
        ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   
   : proof
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   ------------------------------------
        if nfst k ≠ 2 then (if k = 2 ⊗ g.Out then N else 0) = 0
        else (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)

2 subgoals
   : proof
> > # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)
    7.  r ≠ 2 ⊗ g.Out
    8.  nfst r = 2
   ------------------------------------
        rs r = RS (nsnd r)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)
    7.  r ≠ 2 ⊗ g.Out
    8.  nfst r ≠ 2
   ------------------------------------
        rs r = 0

2 subgoals
   : proof
> > # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+3+2+1+1#

Goal proved.
 [.........] ⊢ rs r = 0

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)
    7.  r ≠ 2 ⊗ g.Out
    8.  nfst r = 2
   ------------------------------------
        rs r = RS (nsnd r)
   
   : proof
> > # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+2+1#

Goal proved.
 [.........] ⊢ rs r = RS (nsnd r)

Goal proved.
 [.......]
⊢ rs r =
  if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
  else if nfst r ≠ 2 then 0
  else RS (nsnd r)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   ------------------------------------
        if nfst k ≠ 2 then (if k = 2 ⊗ g.Out then N else 0) = 0
        else (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
   : proof
> > # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+1+1+1+1+0+1+2+0+7+0+0+6+1+1+1+0+9+2+5+17+3+6+9+3+0+0+0+19+28+13+14+0+2+10+18+4+1+0+1+0+2+0+3+0+8+11+2+0+0+0+3+0+0+1+2+1+0+0+0+3+7+3+0+1+3+18+21+0+32+1+3+0+2+3+15+17+0+30+21+1+2+16+0+22+22+26+16+25+51+1+2+0+0+0+0+4+2+8+2+0+2+72+3+0+0+9+3+2+1+73r+2+45+0+8+2+7+15+17+4+8+12+2+2+3+3+31+0+6+1+3+3+65+100+62+51+39+4+0+53+81+0+54r+48+2+4+1+1+4+62+46+12+26+1+1+7+68+32+13+36+55+2+34+15+31+5
Exception raised at folTools.FOL_SOLVER:
Time exception raised
Exception-
   HOL_ERR
     {message = "Time exception raised", origin_function = "FOL_SOLVER",
      origin_structure = "folTools"} raised
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin RS.
       wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs g.Out = N ∧ rs = RS) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k))
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # # # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             ∀k.
                 k ≠ 1 ⊗ fin ⇒
                 rs k =
                 (if k = 2 ⊗ g.Out then N
                  else if nfst k ≠ 2 then 0
                  else RS (nsnd k)) ∧ rs (1 ⊗ fin) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) =
        (λrs.
             rs =
             (λr.
                  if r = 2 ⊗ g.Out then N
                  else if nfst r ≠ 2 then 0
                  else RS (nsnd r)))

2 subgoals
   : proof
> > # # # # # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+2+1#
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+3+2+1+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+1+1+1+1+0+1+2+0+7+0+0+6+1+1+1+0+9+2+5+17+3+6+9+3+0+0+0+19+28+13+14+0+2+10+18+4+1+0+1+0+2+0+3+0+8+11+2+0+0+0+3+0+0+1+2+1+0+0+0+3+7+3+0+1+3+18+21+0+32+1+3+0+2+3+15+17+0+30+21+1+2+16+0+22+22+26+16+25+51+1+2+0+0+0+0+4+2+8+2+0+2+72+3+0+0+9+3+2+1r+73+2+45+0+8+2+7+15+17+4+8+12+2+2+3+3+31+0+6+1+3+3+65+100+62+51+39+4+0+53r+81+0+54+48+2+4+1+1+4+62+46+12+26+1+1+7+68+32+13+36+55+2+34r+15+31+5+32+114
Exception raised at folTools.FOL_SOLVER:
Time exception raised
Exception-
   HOL_ERR
     {message = "Time exception raised", origin_function = "FOL_SOLVER",
      origin_structure = "folTools"} raised
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   ------------------------------------
        if nfst k ≠ 2 then (if k = 2 ⊗ g.Out then N else 0) = 0
        else (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs'. rs' g.Out = rs (2 ⊗ g.Out) ∧ rs' = RS)
    5.  rmcorr f f.q0
          (λrs'. rs' fin = rs (2 ⊗ g.Out) ∧ ∀k. k ≠ fin ⇒ rs' k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)
   ------------------------------------
        rs r =
        if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
        else if nfst r ≠ 2 then 0
        else RS (nsnd r)

2 subgoals
   : proof
> > # # # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+2+1#
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+3+2+1+1#

Goal proved.
 [.......]
⊢ rs r =
  if r = 2 ⊗ g.Out then rs (2 ⊗ g.Out)
  else if nfst r ≠ 2 then 0
  else RS (nsnd r)

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
   ------------------------------------
        if nfst k ≠ 2 then (if k = 2 ⊗ g.Out then N else 0) = 0
        else (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
   : proof
> > # # # OK..
metis: r[+0+19]+0+0+0+0+0+0+0+0+0+0+0+1+0+2+1+2+7+1+0+0+7+0+0+1+0+1+0+1+1+1+0+9+0+7+15+3+6+0+3+3+0+3+15+0+14+15+3+17+0+1+0+0+3+4+3+8+3+1+2+2+3+0+0+0+0+0+12+0+1+0+1+2+1+2+1+2+4+10+1+5+10+4+1+1+3+5+7+24+29+1+3+0+24+27+5+0+0+29+5+5+0+2+8+0+0+4+5+2+21+11+4+1+5+1+0+5+4+15+40+72r+5+4+4+5+2+1+2+1+2+1+1+81+3+4+5+0+21+0+22+6+0+0+0+30+0+0+0+0+0+0+7+19+4+16r+31+62+1+1+0+0
Exception raised at folTools.FOL_SOLVER:
Time exception raised
Exception-
   HOL_ERR
     {message = "Time exception raised", origin_function = "FOL_SOLVER",
      origin_structure = "folTools"} raised
> > # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k = 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k ≠ 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else 0) = 0

2 subgoals
   : proof
> > # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+0+0+0+5+1+0+0+0+0+0+2+0+0+0+1+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> > # OK..
metis: r[+0+5]#

Goal proved.
 [........] ⊢ (if k = 2 ⊗ g.Out then N else 0) = 0

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k = 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  T
    8.  k = 2 ⊗ g.Out
   ------------------------------------
        N = RS g.Out
   
   : proof
> > # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+0+4+1+0+0+0+0+2+0+0+0+1+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > OK..
val it = There are currently no proofs.: proofs
> > # # # # # # # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin RS.
            RS g.Out = N ∧ wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs = RS) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+6]#

Exception raised at Tactical.THEN1:
first subgoal not solved by second tactic (THEN1 on line 2681) (THEN1 on line 2693)
Exception-
   HOL_ERR
     {message =
      "first subgoal not solved by second tactic (THEN1 on line 2681) (THEN1 on line 2693)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> > # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = RS g.Out ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = RS g.Out ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0)
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)
          NONE (λrs. rs (1 ⊗ f.Out) = Op)

2 subgoals
   : proof
> > # # # # # # # # # # # OK..
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+6]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = RS g.Out ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  (∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) ⇔
        ∀k. k ≠ fin ⇒ rs (1 ⊗ k) = 0
   ------------------------------------
        rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin RS.
       RS g.Out = N ∧ wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs = RS) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = RS g.Out ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        ∃Q.
            rmcorr
              (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
               msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (0 ⊗ g.q0)
              (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE Q ∧
            rmcorr (msInst 2 (mrInst 1 f)) (2 ⊗ f.q0) Q NONE
              (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin RS.
       RS g.Out = N ∧ wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs = RS) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = RS g.Out ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr
          (msInst 0 (mrInst 2 g with In := [2 ⊗ gin]) ⇨
           msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1)) ⇨
           msInst 2 (mrInst 1 f)) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs. rs (1 ⊗ f.Out) = Op)
   
   : proof
> # > val it =
   Initial goal:
   
   ∀M N Op f g fin gin RS.
       RS g.Out = N ∧ wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
       rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
         (λrs. rs = RS) ∧
       rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
         (λrs. rs f.Out = Op) ⇒
       rmcorr (Cn f g) (Cn f g).q0
         (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
         NONE (λrs. rs (Cn f g).Out = Op): proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs = RS)
    5.  rmcorr f f.q0 (λrs. rs fin = RS g.Out ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (Cn f g) (Cn f g).q0
          (λrs. rs (HD (Cn f g).In) = M ∧ ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0)
          NONE (λrs. rs (Cn f g).Out = Op)
   
   : proof
> # > OK..
val it = There are currently no proofs.: proofs
> > # # # # # # # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin RS.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k))
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # # # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             ∀k.
                 k ≠ 1 ⊗ fin ⇒
                 rs k =
                 (if k = 2 ⊗ g.Out then N
                  else if nfst k ≠ 2 then 0
                  else RS (nsnd k)) ∧ rs (1 ⊗ fin) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) =
        (λrs.
             rs =
             (λr.
                  if r = 2 ⊗ g.Out then N
                  else if nfst r ≠ 2 then 0
                  else RS (nsnd r)))

2 subgoals
   : proof
> > # # # # # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+2+1#
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+3+2+1+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k = 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k ≠ 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else 0) = 0

2 subgoals
   : proof
> > # OK..
metis: r[+0+5]#

Goal proved.
 [........] ⊢ (if k = 2 ⊗ g.Out then N else 0) = 0

Remaining subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  nfst k = 2
   ------------------------------------
        (if k = 2 ⊗ g.Out then N else RS (nsnd k)) = RS (nsnd k)
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  T
    8.  k = 2 ⊗ g.Out
   ------------------------------------
        N = RS g.Out
   
   : proof
> > # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+0+4+1+0+0+0+0+2+0+0+0+1+0!

Exception raised at folTools.FOL_FIND:
no solution found
Exception-
   HOL_ERR
     {message = "no solution found", origin_function = "FOL_FIND",
      origin_structure = "folTools"} raised
> # > OK..
val it = There are currently no proofs.: proofs
> # > val it = There are currently no proofs.: proofs
> > # # # # # # # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin RS.
            RS g.Out = N ∧ wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N ∧ rs = RS) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+6]#

Exception raised at Tactical.THEN1:
first subgoal not solved by second tactic (THEN1 on line 2681) (THEN1 on line 2693)
Exception-
   HOL_ERR
     {message =
      "first subgoal not solved by second tactic (THEN1 on line 2681) (THEN1 on line 2693)",
      origin_function = "THEN1", origin_structure = "Tactical"} raised
> # > OK..
val it = There are currently no proofs.: proofs
> > # # # # # # # # # val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        ∀M N Op f g fin gin RS.
            wfrm g ∧ wfrm f ∧ g.In = [gin] ∧ f.In = [fin] ∧
            rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
              (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N) ∧
            rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
              (λrs. rs f.Out = Op) ⇒
            rmcorr (Cn f g) (Cn f g).q0
              (λrs.
                   rs (HD (Cn f g).In) = M ∧
                   ∀k. k ≠ HD (Cn f g).In ⇒ rs k = 0) NONE
              (λrs. rs (Cn f g).Out = Op)
   : proofs
> > # # # # # # # # # # # # # # # # # # # # # # # OK..
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+3+0+1+0+3#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+16]+0+0+0+0+0+0+0+0+0+1#
metis: r[+0+6]#
metis: r[+0+17]+0+0+0+0+0+0+0+0+0+0+0+2+2+0+1#
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 0 (mrInst 2 g with In := [2 ⊗ gin])) (0 ⊗ g.q0)
          (λrs. rs (2 ⊗ gin) = M ∧ ∀k. k ≠ 2 ⊗ gin ⇒ rs k = 0) NONE
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k))
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        rmcorr (msInst 1 (dup (2 ⊗ g.Out) (1 ⊗ fin) (0 ⊗ 1))) (1 ⊗ 0)
          (λrs.
               rs (2 ⊗ g.Out) = N ∧
               ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) NONE
          (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0)

2 subgoals
   : proof
> > # # # # # OK..
2 subgoals:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs. rs (1 ⊗ fin) = N ∧ ∀k. k ≠ 1 ⊗ fin ∧ nfst k = 1 ⇒ rs k = 0) =
        (λrs.
             ∀k.
                 k ≠ 1 ⊗ fin ⇒
                 rs k =
                 (if k = 2 ⊗ g.Out then N
                  else if nfst k ≠ 2 then 0
                  else RS (nsnd k)) ∧ rs (1 ⊗ fin) = N)
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
   ------------------------------------
        (λrs.
             rs (2 ⊗ g.Out) = N ∧
             ∀k. if nfst k ≠ 2 then rs k = 0 else rs k = RS (nsnd k)) =
        (λrs.
             rs =
             (λr.
                  if r = 2 ⊗ g.Out then N
                  else if nfst r ≠ 2 then 0
                  else RS (nsnd r)))

2 subgoals
   : proof
> > # # # # # # # OK..
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+2+1#
metis: r[+0+15]+0+0+0+0+0+0+0+0+0+0+3+2+1+1#
metis: r[+0+5]#
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  T
    8.  k = 2 ⊗ g.Out
   ------------------------------------
        N = RS g.Out
   
   : proof
> > # OK..
1 subgoal:
val it =
   
    0.  wfrm g
    1.  wfrm f
    2.  g.In = [gin]
    3.  f.In = [fin]
    4.  rmcorr g g.q0 (λrs. rs gin = M ∧ ∀k. k ≠ gin ⇒ rs k = 0) NONE
          (λrs. rs g.Out = N ∧ rs = RS ∧ RS g.Out = N)
    5.  rmcorr f f.q0 (λrs. rs fin = N ∧ ∀k. k ≠ fin ⇒ rs k = 0) NONE
          (λrs. rs f.Out = Op)
    6.  ∀r.
            rs r =
            if r = 2 ⊗ g.Out then N
            else if nfst r ≠ 2 then 0
            else RS (nsnd r)
    7.  T
    8.  k = 2 ⊗ g.Out
   ------------------------------------
        N = RS g.Out
   
   : proof
> > # OK..

Exception raised at BasicProvers.by:
by's tactic failed to prove subgoal on line 2710
Exception-
   HOL_ERR
     {message = "by's tactic failed to prove subgoal on line 2710",
      origin_function = "by", origin_structure = "BasicProvers"} raised
> 